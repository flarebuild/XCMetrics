// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: build_event_stream/build_event_stream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumeration type characterizing the size of a test, as specified by the
/// test rule.
public enum BuildEventStream_TestSize: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case small // = 1
  case medium // = 2
  case large // = 3
  case enormous // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .small
    case 2: self = .medium
    case 3: self = .large
    case 4: self = .enormous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .small: return 1
    case .medium: return 2
    case .large: return 3
    case .enormous: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestSize] = [
    .unknown,
    .small,
    .medium,
    .large,
    .enormous,
  ]
}

#endif  // swift(>=4.2)

public enum BuildEventStream_TestStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noStatus // = 0
  case passed // = 1
  case flaky // = 2
  case timeout // = 3
  case failed // = 4
  case incomplete // = 5
  case remoteFailure // = 6
  case failedToBuild // = 7
  case toolHaltedBeforeTesting // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStatus
    case 1: self = .passed
    case 2: self = .flaky
    case 3: self = .timeout
    case 4: self = .failed
    case 5: self = .incomplete
    case 6: self = .remoteFailure
    case 7: self = .failedToBuild
    case 8: self = .toolHaltedBeforeTesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStatus: return 0
    case .passed: return 1
    case .flaky: return 2
    case .timeout: return 3
    case .failed: return 4
    case .incomplete: return 5
    case .remoteFailure: return 6
    case .failedToBuild: return 7
    case .toolHaltedBeforeTesting: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestStatus] = [
    .noStatus,
    .passed,
    .flaky,
    .timeout,
    .failed,
    .incomplete,
    .remoteFailure,
    .failedToBuild,
    .toolHaltedBeforeTesting,
  ]
}

#endif  // swift(>=4.2)

/// Identifier for a build event. It is deliberately structured to also provide
/// information about which build target etc the event is related to.
///
/// Events are chained via the event id as follows: each event has an id and a
/// set of ids of children events such that apart from the initial event each
/// event has an id that is mentioned as child id in an earlier event and a build
/// invocation is complete if and only if all direct and indirect children of the
/// initial event have been posted.
public struct BuildEventStream_BuildEventId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var unknown: BuildEventStream_BuildEventId.UnknownBuildEventId {
    get {
      if case .unknown(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnknownBuildEventId()
    }
    set {_uniqueStorage()._id = .unknown(newValue)}
  }

  public var progress: BuildEventStream_BuildEventId.ProgressId {
    get {
      if case .progress(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ProgressId()
    }
    set {_uniqueStorage()._id = .progress(newValue)}
  }

  public var started: BuildEventStream_BuildEventId.BuildStartedId {
    get {
      if case .started(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildStartedId()
    }
    set {_uniqueStorage()._id = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_BuildEventId.UnstructuredCommandLineId {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnstructuredCommandLineId()
    }
    set {_uniqueStorage()._id = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: BuildEventStream_BuildEventId.StructuredCommandLineId {
    get {
      if case .structuredCommandLine(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.StructuredCommandLineId()
    }
    set {_uniqueStorage()._id = .structuredCommandLine(newValue)}
  }

  public var workspaceStatus: BuildEventStream_BuildEventId.WorkspaceStatusId {
    get {
      if case .workspaceStatus(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.WorkspaceStatusId()
    }
    set {_uniqueStorage()._id = .workspaceStatus(newValue)}
  }

  public var optionsParsed: BuildEventStream_BuildEventId.OptionsParsedId {
    get {
      if case .optionsParsed(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.OptionsParsedId()
    }
    set {_uniqueStorage()._id = .optionsParsed(newValue)}
  }

  public var fetch: BuildEventStream_BuildEventId.FetchId {
    get {
      if case .fetch(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.FetchId()
    }
    set {_uniqueStorage()._id = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {
      if case .configuration(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConfigurationId()
    }
    set {_uniqueStorage()._id = .configuration(newValue)}
  }

  public var targetConfigured: BuildEventStream_BuildEventId.TargetConfiguredId {
    get {
      if case .targetConfigured(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetConfiguredId()
    }
    set {_uniqueStorage()._id = .targetConfigured(newValue)}
  }

  public var pattern: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .pattern(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {_uniqueStorage()._id = .pattern(newValue)}
  }

  public var patternSkipped: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .patternSkipped(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {_uniqueStorage()._id = .patternSkipped(newValue)}
  }

  public var namedSet: BuildEventStream_BuildEventId.NamedSetOfFilesId {
    get {
      if case .namedSet(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.NamedSetOfFilesId()
    }
    set {_uniqueStorage()._id = .namedSet(newValue)}
  }

  public var targetCompleted: BuildEventStream_BuildEventId.TargetCompletedId {
    get {
      if case .targetCompleted(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetCompletedId()
    }
    set {_uniqueStorage()._id = .targetCompleted(newValue)}
  }

  public var actionCompleted: BuildEventStream_BuildEventId.ActionCompletedId {
    get {
      if case .actionCompleted(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ActionCompletedId()
    }
    set {_uniqueStorage()._id = .actionCompleted(newValue)}
  }

  public var unconfiguredLabel: BuildEventStream_BuildEventId.UnconfiguredLabelId {
    get {
      if case .unconfiguredLabel(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnconfiguredLabelId()
    }
    set {_uniqueStorage()._id = .unconfiguredLabel(newValue)}
  }

  public var configuredLabel: BuildEventStream_BuildEventId.ConfiguredLabelId {
    get {
      if case .configuredLabel(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConfiguredLabelId()
    }
    set {_uniqueStorage()._id = .configuredLabel(newValue)}
  }

  public var testResult: BuildEventStream_BuildEventId.TestResultId {
    get {
      if case .testResult(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TestResultId()
    }
    set {_uniqueStorage()._id = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_BuildEventId.TestSummaryId {
    get {
      if case .testSummary(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TestSummaryId()
    }
    set {_uniqueStorage()._id = .testSummary(newValue)}
  }

  public var targetSummary: BuildEventStream_BuildEventId.TargetSummaryId {
    get {
      if case .targetSummary(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetSummaryId()
    }
    set {_uniqueStorage()._id = .targetSummary(newValue)}
  }

  public var buildFinished: BuildEventStream_BuildEventId.BuildFinishedId {
    get {
      if case .buildFinished(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildFinishedId()
    }
    set {_uniqueStorage()._id = .buildFinished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildEventId.BuildToolLogsId {
    get {
      if case .buildToolLogs(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildToolLogsId()
    }
    set {_uniqueStorage()._id = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildEventId.BuildMetricsId {
    get {
      if case .buildMetrics(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildMetricsId()
    }
    set {_uniqueStorage()._id = .buildMetrics(newValue)}
  }

  public var workspace: BuildEventStream_BuildEventId.WorkspaceConfigId {
    get {
      if case .workspace(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.WorkspaceConfigId()
    }
    set {_uniqueStorage()._id = .workspace(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildEventId.BuildMetadataId {
    get {
      if case .buildMetadata(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildMetadataId()
    }
    set {_uniqueStorage()._id = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId {
    get {
      if case .convenienceSymlinksIdentified(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId()
    }
    set {_uniqueStorage()._id = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable {
    case unknown(BuildEventStream_BuildEventId.UnknownBuildEventId)
    case progress(BuildEventStream_BuildEventId.ProgressId)
    case started(BuildEventStream_BuildEventId.BuildStartedId)
    case unstructuredCommandLine(BuildEventStream_BuildEventId.UnstructuredCommandLineId)
    case structuredCommandLine(BuildEventStream_BuildEventId.StructuredCommandLineId)
    case workspaceStatus(BuildEventStream_BuildEventId.WorkspaceStatusId)
    case optionsParsed(BuildEventStream_BuildEventId.OptionsParsedId)
    case fetch(BuildEventStream_BuildEventId.FetchId)
    case configuration(BuildEventStream_BuildEventId.ConfigurationId)
    case targetConfigured(BuildEventStream_BuildEventId.TargetConfiguredId)
    case pattern(BuildEventStream_BuildEventId.PatternExpandedId)
    case patternSkipped(BuildEventStream_BuildEventId.PatternExpandedId)
    case namedSet(BuildEventStream_BuildEventId.NamedSetOfFilesId)
    case targetCompleted(BuildEventStream_BuildEventId.TargetCompletedId)
    case actionCompleted(BuildEventStream_BuildEventId.ActionCompletedId)
    case unconfiguredLabel(BuildEventStream_BuildEventId.UnconfiguredLabelId)
    case configuredLabel(BuildEventStream_BuildEventId.ConfiguredLabelId)
    case testResult(BuildEventStream_BuildEventId.TestResultId)
    case testSummary(BuildEventStream_BuildEventId.TestSummaryId)
    case targetSummary(BuildEventStream_BuildEventId.TargetSummaryId)
    case buildFinished(BuildEventStream_BuildEventId.BuildFinishedId)
    case buildToolLogs(BuildEventStream_BuildEventId.BuildToolLogsId)
    case buildMetrics(BuildEventStream_BuildEventId.BuildMetricsId)
    case workspace(BuildEventStream_BuildEventId.WorkspaceConfigId)
    case buildMetadata(BuildEventStream_BuildEventId.BuildMetadataId)
    case convenienceSymlinksIdentified(BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEventId.OneOf_ID, rhs: BuildEventStream_BuildEventId.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.unknown(let l), .unknown(let r)): return l == r
      case (.progress(let l), .progress(let r)): return l == r
      case (.started(let l), .started(let r)): return l == r
      case (.unstructuredCommandLine(let l), .unstructuredCommandLine(let r)): return l == r
      case (.structuredCommandLine(let l), .structuredCommandLine(let r)): return l == r
      case (.workspaceStatus(let l), .workspaceStatus(let r)): return l == r
      case (.optionsParsed(let l), .optionsParsed(let r)): return l == r
      case (.fetch(let l), .fetch(let r)): return l == r
      case (.configuration(let l), .configuration(let r)): return l == r
      case (.targetConfigured(let l), .targetConfigured(let r)): return l == r
      case (.pattern(let l), .pattern(let r)): return l == r
      case (.patternSkipped(let l), .patternSkipped(let r)): return l == r
      case (.namedSet(let l), .namedSet(let r)): return l == r
      case (.targetCompleted(let l), .targetCompleted(let r)): return l == r
      case (.actionCompleted(let l), .actionCompleted(let r)): return l == r
      case (.unconfiguredLabel(let l), .unconfiguredLabel(let r)): return l == r
      case (.configuredLabel(let l), .configuredLabel(let r)): return l == r
      case (.testResult(let l), .testResult(let r)): return l == r
      case (.testSummary(let l), .testSummary(let r)): return l == r
      case (.targetSummary(let l), .targetSummary(let r)): return l == r
      case (.buildFinished(let l), .buildFinished(let r)): return l == r
      case (.buildToolLogs(let l), .buildToolLogs(let r)): return l == r
      case (.buildMetrics(let l), .buildMetrics(let r)): return l == r
      case (.workspace(let l), .workspace(let r)): return l == r
      case (.buildMetadata(let l), .buildMetadata(let r)): return l == r
      case (.convenienceSymlinksIdentified(let l), .convenienceSymlinksIdentified(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Generic identifier for a build event. This is the default type of
  /// BuildEventId, but should not be used outside testing; nevertheless,
  /// tools should handle build events with this kind of id gracefully.
  public struct UnknownBuildEventId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting progress. Those events are also used to
  /// chain in events that come early.
  public struct ProgressId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique identifier. No assumption should be made about how the ids are
    /// assigned; the only meaningful operation on this field is test for
    /// equality.
    public var opaqueCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the beginning of a build; this will
  /// normally be the first event.
  public struct BuildStartedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event indicating the original commandline received by
  /// the bazel server.
  public struct UnstructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event describing the commandline received by Bazel.
  public struct StructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A title for this command line value, as there may be multiple.
    /// For example, a single invocation may wish to report both the literal and
    /// canonical command lines, and this label would be used to differentiate
    /// between both versions.
    public var commandLineLabel: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the workspace status.
  public struct WorkspaceStatusId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event reporting on the options included in the command
  /// line, both explicitly and implicitly.
  public struct OptionsParsedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting that an external resource was fetched
  /// from.
  public struct FetchId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The external resource that was fetched from.
    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target pattern has been expanded
  /// further.
  /// Messages of this shape are also used to describe parts of a pattern that
  /// have been skipped for some reason, if the actual expansion was still
  /// carried out (e.g., if keep_going is set). In this case, the
  /// pattern_skipped choice in the id field is to be made.
  public struct PatternExpandedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pattern: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WorkspaceConfigId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildMetadataId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target has been expanded by
  /// identifying for which configurations it should be build.
  public struct TargetConfiguredId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    /// If empty, the id refers to the expansion of the target. If not-empty,
    /// the id refers to the expansion of an aspect applied to the (already
    /// expanded) target.
    ///
    /// For example, when building an apple_binary that depends on proto_library
    /// "//:foo_proto", there will be two TargetConfigured events for
    /// "//:foo_proto":
    ///
    /// 1. An event with an empty aspect, corresponding to actions producing
    /// language-agnostic outputs from the proto_library; and
    /// 2. An event with aspect "ObjcProtoAspect", corresponding to Objective-C
    /// code generation.
    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a named set of files (usually artifacts)
  /// to be referred to in later messages.
  public struct NamedSetOfFilesId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the file set; this is an opaque string valid only for the
    /// particular instance of the event stream.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a configuration.
  public struct ConfigurationId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the configuration; users of the protocol should not make
    /// any assumptions about it having any structure, or equality of the
    /// identifier between different streams.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target was built completely; this
  /// does not include running the test if the target is a test target.
  public struct TargetCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    /// The configuration for which the target was built.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    /// If empty, the id refers to the completion of the target. If not-empty,
    /// the id refers to the completion of an aspect applied to the (already
    /// completed) target.
    ///
    /// For example, when building an apple_binary that depends on proto_library
    /// "//:foo_proto", there will be two TargetCompleted events for
    /// "//:foo_proto":
    ///
    /// 1. An event with an empty aspect, corresponding to actions producing
    /// language-agnostic outputs from the proto_library; and
    /// 2. An event with aspect "ObjcProtoAspect", corresponding to Objective-C
    /// code generation.
    public var aspect: String {
      get {return _storage._aspect}
      set {_uniqueStorage()._aspect = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting that an action was completed (not all
  /// actions are reported, only the ones that can be considered important;
  /// this includes all failed actions).
  public struct ActionCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var primaryOutput: String {
      get {return _storage._primaryOutput}
      set {_uniqueStorage()._primaryOutput = newValue}
    }

    /// Optional, the label of the owner of the action, for reference.
    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    /// Optional, the id of the configuration of the action owner.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting an event associated with an unconfigured
  /// label. Usually, this indicates a failure due to a missing input file. In
  /// any case, it will report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier. The
  /// purpose of those events is to serve as the root cause of a failed target.
  public struct UnconfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting an event associated with a configured
  /// label, usually a visibility error. In any case, an event with such an
  /// id will always report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier.
  public struct ConfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting on an individual test run. The label
  /// identifies the test that is reported about, the remaining fields are
  /// in such a way as to uniquely identify the action within a build. In fact,
  /// attempts for the same test, run, shard triple are counted sequentially,
  /// starting with 1.
  public struct TestResultId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var run: Int32 {
      get {return _storage._run}
      set {_uniqueStorage()._run = newValue}
    }

    public var shard: Int32 {
      get {return _storage._shard}
      set {_uniqueStorage()._shard = newValue}
    }

    public var attempt: Int32 {
      get {return _storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting the summary of a test.
  public struct TestSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting the summary of a target.
  public struct TargetSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of the BuildFinished event, indicating the end of a build.
  public struct BuildFinishedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing additional logs/statistics after
  /// completion of the build.
  public struct BuildToolLogsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing build metrics after completion
  /// of the build.
  public struct BuildMetricsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing convenience symlinks information.
  public struct ConvenienceSymlinksIdentifiedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of an event summarizing the progress of the build so far. Those
/// events are also used to be parents of events where the more logical parent
/// event cannot be posted yet as the needed information is not yet complete.
public struct BuildEventStream_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next chunk of stdout that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stdout: String = String()

  /// The next chunk of stderr that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stderr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event indicating that an expected event will not come, as
/// the build is aborted prematurely for some reason.
public struct BuildEventStream_Aborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: BuildEventStream_Aborted.AbortReason = .unknown

  /// A human readable description with more details about there reason, where
  /// available and useful.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AbortReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// The user requested the build to be aborted (e.g., by hitting Ctl-C).
    case userInterrupted // = 1

    /// The user requested that no analysis be performed.
    case noAnalyze // = 8

    /// The user requested that no build be carried out.
    case noBuild // = 9

    /// The build or target was aborted as a timeout was exceeded.
    case timeOut // = 2

    /// The build or target was aborted as some remote environment (e.g., for
    /// remote execution of actions) was not available in the expected way.
    case remoteEnvironmentFailure // = 3

    /// Failure due to reasons entirely internal to the build tool, i.e. an
    /// unexpected crash due to programmer error.
    case `internal` // = 4

    /// A Failure occurred in the loading phase of a target.
    case loadingFailure // = 5

    /// A Failure occurred in the analysis phase of a target.
    case analysisFailure // = 6

    /// Target build was skipped (e.g. due to incompatible CPU constraints).
    case skipped // = 7

    /// Build incomplete due to an earlier build failure (e.g. --keep_going was
    /// set to false causing the build be ended upon failure).
    case incomplete // = 10

    /// The build tool ran out of memory and crashed.
    case outOfMemory // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .userInterrupted
      case 2: self = .timeOut
      case 3: self = .remoteEnvironmentFailure
      case 4: self = .internal
      case 5: self = .loadingFailure
      case 6: self = .analysisFailure
      case 7: self = .skipped
      case 8: self = .noAnalyze
      case 9: self = .noBuild
      case 10: self = .incomplete
      case 11: self = .outOfMemory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .userInterrupted: return 1
      case .timeOut: return 2
      case .remoteEnvironmentFailure: return 3
      case .internal: return 4
      case .loadingFailure: return 5
      case .analysisFailure: return 6
      case .skipped: return 7
      case .noAnalyze: return 8
      case .noBuild: return 9
      case .incomplete: return 10
      case .outOfMemory: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_Aborted.AbortReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_Aborted.AbortReason] = [
    .unknown,
    .userInterrupted,
    .noAnalyze,
    .noBuild,
    .timeOut,
    .remoteEnvironmentFailure,
    .internal,
    .loadingFailure,
    .analysisFailure,
    .skipped,
    .incomplete,
    .outOfMemory,
  ]
}

#endif  // swift(>=4.2)

/// Payload of an event indicating the beginning of a new build. Usually, events
/// of those type start a new build-event stream. The target pattern requested
/// to be build is contained in one of the announced child events; it is an
/// invariant that precisely one of the announced child events has a non-empty
/// target pattern.
public struct BuildEventStream_BuildStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  /// Start of the build in ms since the epoch.
  /// TODO(buchgr): Use google.protobuf.TimeStamp once bazel's protoc supports
  /// it.
  public var startTimeMillis: Int64 = 0

  /// Version of the build tool that is running.
  public var buildToolVersion: String = String()

  /// A human-readable description of all the non-default option settings
  public var optionsDescription: String = String()

  /// The name of the command that the user invoked.
  public var command: String = String()

  /// The working directory from which the build tool was invoked.
  public var workingDirectory: String = String()

  /// The directory of the workspace.
  public var workspaceDirectory: String = String()

  /// The process ID of the Bazel server.
  public var serverPid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration related to the blaze workspace and output tree.
public struct BuildEventStream_WorkspaceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root of the local blaze exec root. All output files live underneath
  /// this at "blaze-out/".
  public var localExecRoot: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the command-line of the invocation as
/// originally received by the server. Note that this is not the command-line
/// given by the user, as the client adds information about the invocation,
/// like name and relevant entries of rc-files and client environment variables.
/// However, it does contain enough information to reproduce the build
/// invocation.
public struct BuildEventStream_UnstructuredCommandLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting on the parsed options, grouped in various ways.
public struct BuildEventStream_OptionsParsed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startupOptions: [String] {
    get {return _storage._startupOptions}
    set {_uniqueStorage()._startupOptions = newValue}
  }

  public var explicitStartupOptions: [String] {
    get {return _storage._explicitStartupOptions}
    set {_uniqueStorage()._explicitStartupOptions = newValue}
  }

  public var cmdLine: [String] {
    get {return _storage._cmdLine}
    set {_uniqueStorage()._cmdLine = newValue}
  }

  public var explicitCmdLine: [String] {
    get {return _storage._explicitCmdLine}
    set {_uniqueStorage()._explicitCmdLine = newValue}
  }

  public var invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy {
    get {return _storage._invocationPolicy ?? Blaze_InvocationPolicy_InvocationPolicy()}
    set {_uniqueStorage()._invocationPolicy = newValue}
  }
  /// Returns true if `invocationPolicy` has been explicitly set.
  public var hasInvocationPolicy: Bool {return _storage._invocationPolicy != nil}
  /// Clears the value of `invocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInvocationPolicy() {_uniqueStorage()._invocationPolicy = nil}

  public var toolTag: String {
    get {return _storage._toolTag}
    set {_uniqueStorage()._toolTag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of an event indicating that an external resource was fetched. This
/// event will only occur in streams where an actual fetch happened, not in ones
/// where a cached copy of the entity to be fetched was used.
public struct BuildEventStream_Fetch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the workspace status. Key-value pairs can be
/// provided by specifying the workspace_status_command to an executable that
/// returns one key-value pair per line of output (key and value separated by a
/// space).
public struct BuildEventStream_WorkspaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [BuildEventStream_WorkspaceStatus.Item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Item {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of an event reporting custom key-value metadata associated with the
/// build.
public struct BuildEventStream_BuildMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Custom metadata for the build.
  public var metadata: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting details of a given configuration.
public struct BuildEventStream_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mnemonic: String = String()

  public var platformName: String = String()

  public var cpu: String = String()

  public var makeVariable: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the expansion of a target pattern.
/// The main information is in the chaining part: the id will contain the
/// target pattern that was expanded and the children id will contain the
/// target or target pattern it was expanded to.
public struct BuildEventStream_PatternExpanded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All test suites requested via top-level target patterns. Does not include
  /// test suites whose label matched a negative pattern.
  public var testSuiteExpansions: [BuildEventStream_PatternExpanded.TestSuiteExpansion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents a test_suite target and the tests that it expanded to. Nested
  /// test suites are recursively expanded. The test labels only contain the
  /// final test targets, not any nested suites.
  public struct TestSuiteExpansion {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The label of the test_suite rule.
    public var suiteLabel: String = String()

    /// Labels of the test targets included in the suite. Includes all tests in
    /// the suite regardless of any filters or negative patterns which may result
    /// in the test not actually being run.
    public var testLabels: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of the event indicating that the configurations for a target have
/// been identified. As with pattern expansion the main information is in the
/// chaining part: the id will contain the target that was configured and the
/// children id will contain the configured targets it was configured to.
public struct BuildEventStream_TargetConfigured {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// List of all tags associated with this target (for all possible
  /// configurations).
  public var tag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sequence of prefixes to apply to the file name to construct a full path.
  /// In most but not all cases, there will be 3 entries:
  ///  1. A root output directory, eg "bazel-out"
  ///  2. A configuration mnemonic, eg "k8-fastbuild"
  ///  3. An output category, eg "genfiles"
  public var pathPrefix: [String] = []

  /// identifier indicating the nature of the file (e.g., "stdout", "stderr")
  public var name: String = String()

  public var file: BuildEventStream_File.OneOf_File? = nil

  /// A location where the contents of the file can be found. The string is
  /// encoded according to RFC2396.
  public var uri: String {
    get {
      if case .uri(let v)? = file {return v}
      return String()
    }
    set {file = .uri(newValue)}
  }

  /// The contents of the file, if they are guaranteed to be short.
  public var contents: Data {
    get {
      if case .contents(let v)? = file {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {file = .contents(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_File: Equatable {
    /// A location where the contents of the file can be found. The string is
    /// encoded according to RFC2396.
    case uri(String)
    /// The contents of the file, if they are guaranteed to be short.
    case contents(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_File.OneOf_File, rhs: BuildEventStream_File.OneOf_File) -> Bool {
      switch (lhs, rhs) {
      case (.uri(let l), .uri(let r)): return l == r
      case (.contents(let l), .contents(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Payload of a message to describe a set of files, usually build artifacts, to
/// be referred to later by their name. In this way, files that occur identically
/// as outputs of several targets have to be named only once.
public struct BuildEventStream_NamedSetOfFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Files that belong to this named set of files.
  public var files: [BuildEventStream_File] = []

  /// Other named sets whose members also belong to this set.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of an action. The main purpose
/// of posting those events is to provide details on the root cause for a target
/// failing; however, consumers of the build-event protocol must not assume
/// that only failed actions are posted.
public struct BuildEventStream_ActionExecuted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  /// The mnemonic of the action that was executed
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// The exit code of the action, if it is available.
  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  /// Location where to find the standard output of the action
  /// (e.g., a file path).
  public var stdout: BuildEventStream_File {
    get {return _storage._stdout ?? BuildEventStream_File()}
    set {_uniqueStorage()._stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  public var hasStdout: Bool {return _storage._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  public mutating func clearStdout() {_uniqueStorage()._stdout = nil}

  /// Location where to find the standard error of the action
  /// (e.g., a file path).
  public var stderr: BuildEventStream_File {
    get {return _storage._stderr ?? BuildEventStream_File()}
    set {_uniqueStorage()._stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  public var hasStderr: Bool {return _storage._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  public mutating func clearStderr() {_uniqueStorage()._stderr = nil}

  /// Deprecated. This field is now present on ActionCompletedId.
  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  /// Deprecated. This field is now present on ActionCompletedId.
  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  /// Primary output; only provided for successful actions.
  public var primaryOutput: BuildEventStream_File {
    get {return _storage._primaryOutput ?? BuildEventStream_File()}
    set {_uniqueStorage()._primaryOutput = newValue}
  }
  /// Returns true if `primaryOutput` has been explicitly set.
  public var hasPrimaryOutput: Bool {return _storage._primaryOutput != nil}
  /// Clears the value of `primaryOutput`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryOutput() {_uniqueStorage()._primaryOutput = nil}

  /// The command-line of the action, if the action is a command.
  public var commandLine: [String] {
    get {return _storage._commandLine}
    set {_uniqueStorage()._commandLine = newValue}
  }

  /// List of paths to log files
  public var actionMetadataLogs: [BuildEventStream_File] {
    get {return _storage._actionMetadataLogs}
    set {_uniqueStorage()._actionMetadataLogs = newValue}
  }

  /// Only populated if success = false, and sometimes not even then.
  public var failureDetail: FailureDetails_FailureDetail {
    get {return _storage._failureDetail ?? FailureDetails_FailureDetail()}
    set {_uniqueStorage()._failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return _storage._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {_uniqueStorage()._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Collection of all output files belonging to that output group.
public struct BuildEventStream_OutputGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the output group
  public var name: String = String()

  /// List of file sets that belong to this output group as well.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of a target. The target is
/// specified in the id. If the target failed the root causes are provided as
/// children events.
public struct BuildEventStream_TargetComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  /// Deprecated: use the target_kind field in TargetConfigured instead.
  public var targetKind: String {
    get {return _storage._targetKind}
    set {_uniqueStorage()._targetKind = newValue}
  }

  /// The size of the test, if the target is a test target. Unset otherwise.
  /// Deprecated: use the test_size field in TargetConfigured instead.
  public var testSize: BuildEventStream_TestSize {
    get {return _storage._testSize}
    set {_uniqueStorage()._testSize = newValue}
  }

  /// The output files are arranged by their output group. If an output file
  /// is part of multiple output groups, it appears once in each output
  /// group.
  public var outputGroup: [BuildEventStream_OutputGroup] {
    get {return _storage._outputGroup}
    set {_uniqueStorage()._outputGroup = newValue}
  }

  /// Temporarily, also report the important outputs directly. This is only to
  /// allow existing clients help transition to the deduplicated representation;
  /// new clients should not use it.
  public var importantOutput: [BuildEventStream_File] {
    get {return _storage._importantOutput}
    set {_uniqueStorage()._importantOutput = newValue}
  }

  /// Report output artifacts (referenced transitively via output_group) which
  /// emit directories instead of singleton files. These directory_output entries
  /// will never include a uri.
  public var directoryOutput: [BuildEventStream_File] {
    get {return _storage._directoryOutput}
    set {_uniqueStorage()._directoryOutput = newValue}
  }

  /// List of tags associated with this configured target.
  public var tag: [String] {
    get {return _storage._tag}
    set {_uniqueStorage()._tag = newValue}
  }

  /// The timeout specified for test actions under this configured target.
  public var testTimeoutSeconds: Int64 {
    get {return _storage._testTimeoutSeconds}
    set {_uniqueStorage()._testTimeoutSeconds = newValue}
  }

  /// Failure information about the target, only populated if success is false,
  /// and sometimes not even then. Equal to one of the ActionExecuted
  /// failure_detail fields for one of the root cause ActionExecuted events.
  public var failureDetail: FailureDetails_FailureDetail {
    get {return _storage._failureDetail ?? FailureDetails_FailureDetail()}
    set {_uniqueStorage()._failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return _storage._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {_uniqueStorage()._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload on events reporting about individual test action.
public struct BuildEventStream_TestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of this test.
  public var status: BuildEventStream_TestStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Additional details about the status of the test. This is intended for
  /// user display and must not be parsed.
  public var statusDetails: String {
    get {return _storage._statusDetails}
    set {_uniqueStorage()._statusDetails = newValue}
  }

  /// True, if the reported attempt is taken from the tool's local cache.
  public var cachedLocally: Bool {
    get {return _storage._cachedLocally}
    set {_uniqueStorage()._cachedLocally = newValue}
  }

  /// Time in milliseconds since the epoch at which the test attempt was started.
  /// Note: for cached test results, this is time can be before the start of the
  /// build.
  public var testAttemptStartMillisEpoch: Int64 {
    get {return _storage._testAttemptStartMillisEpoch}
    set {_uniqueStorage()._testAttemptStartMillisEpoch = newValue}
  }

  /// Time the test took to run. For locally cached results, this is the time
  /// the cached invocation took when it was invoked.
  public var testAttemptDurationMillis: Int64 {
    get {return _storage._testAttemptDurationMillis}
    set {_uniqueStorage()._testAttemptDurationMillis = newValue}
  }

  /// Files (logs, test.xml, undeclared outputs, etc) generated by that test
  /// action.
  public var testActionOutput: [BuildEventStream_File] {
    get {return _storage._testActionOutput}
    set {_uniqueStorage()._testActionOutput = newValue}
  }

  /// Warnings generated by that test action.
  public var warning: [String] {
    get {return _storage._warning}
    set {_uniqueStorage()._warning = newValue}
  }

  public var executionInfo: BuildEventStream_TestResult.ExecutionInfo {
    get {return _storage._executionInfo ?? BuildEventStream_TestResult.ExecutionInfo()}
    set {_uniqueStorage()._executionInfo = newValue}
  }
  /// Returns true if `executionInfo` has been explicitly set.
  public var hasExecutionInfo: Bool {return _storage._executionInfo != nil}
  /// Clears the value of `executionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionInfo() {_uniqueStorage()._executionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message providing optional meta data on the execution of the test action,
  /// if available.
  public struct ExecutionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated, use TargetComplete.test_timeout_seconds instead.
    public var timeoutSeconds: Int32 {
      get {return _storage._timeoutSeconds}
      set {_uniqueStorage()._timeoutSeconds = newValue}
    }

    /// Name of the strategy to execute this test action (e.g., "local",
    /// "remote")
    public var strategy: String {
      get {return _storage._strategy}
      set {_uniqueStorage()._strategy = newValue}
    }

    /// True, if the reported attempt was a cache hit in a remote cache.
    public var cachedRemotely: Bool {
      get {return _storage._cachedRemotely}
      set {_uniqueStorage()._cachedRemotely = newValue}
    }

    /// The exit code of the test action.
    public var exitCode: Int32 {
      get {return _storage._exitCode}
      set {_uniqueStorage()._exitCode = newValue}
    }

    /// The hostname of the machine where the test action was executed (in case
    /// of remote execution), if known.
    public var hostname: String {
      get {return _storage._hostname}
      set {_uniqueStorage()._hostname = newValue}
    }

    public var timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown {
      get {return _storage._timingBreakdown ?? BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown()}
      set {_uniqueStorage()._timingBreakdown = newValue}
    }
    /// Returns true if `timingBreakdown` has been explicitly set.
    public var hasTimingBreakdown: Bool {return _storage._timingBreakdown != nil}
    /// Clears the value of `timingBreakdown`. Subsequent reads from it will return its default value.
    public mutating func clearTimingBreakdown() {_uniqueStorage()._timingBreakdown = nil}

    public var resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] {
      get {return _storage._resourceUsage}
      set {_uniqueStorage()._resourceUsage = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents a hierarchical timing breakdown of an activity.
    /// The top level time should be the total time of the activity.
    /// Invariant: time_millis >= sum of time_millis of all direct children.
    public struct TimingBreakdown {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var child: [BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown] = []

      public var name: String = String()

      public var timeMillis: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct ResourceUsage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of the event summarizing a test.
public struct BuildEventStream_TestSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wrapper around BlazeTestStatus to support importing that enum to proto3.
  /// Overall status of test, accumulated over all runs, shards, and attempts.
  public var overallStatus: BuildEventStream_TestStatus = .noStatus

  /// Total number of runs
  public var totalRunCount: Int32 = 0

  /// Number of runs.
  public var runCount: Int32 = 0

  /// Number of shards.
  public var shardCount: Int32 = 0

  /// Path to logs of passed runs.
  public var passed: [BuildEventStream_File] = []

  /// Path to logs of failed runs;
  public var failed: [BuildEventStream_File] = []

  /// Total number of cached test actions
  public var totalNumCached: Int32 = 0

  /// When the test first started running.
  public var firstStartTimeMillis: Int64 = 0

  /// When the last test action completed.
  public var lastStopTimeMillis: Int64 = 0

  /// The total runtime of the test.
  public var totalRunDurationMillis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event summarizing a target (test or non-test).
public struct BuildEventStream_TargetSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Conjunction of TargetComplete events for this target, including aspects.
  public var overallBuildSuccess: Bool = false

  /// Repeats TestSummary's overall_status if available.
  public var overallTestStatus: BuildEventStream_TestStatus = .noStatus

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event indicating the end of a build.
public struct BuildEventStream_BuildFinished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the build succeeded or failed.
  public var overallSuccess: Bool {
    get {return _storage._overallSuccess}
    set {_uniqueStorage()._overallSuccess = newValue}
  }

  /// The overall status of the build. A build was successful iff
  /// ExitCode.code equals 0.
  public var exitCode: BuildEventStream_BuildFinished.ExitCode {
    get {return _storage._exitCode ?? BuildEventStream_BuildFinished.ExitCode()}
    set {_uniqueStorage()._exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return _storage._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {_uniqueStorage()._exitCode = nil}

  /// Time in milliseconds since the epoch.
  /// TODO(buchgr): Use google.protobuf.Timestamp once bazel's protoc supports
  /// it.
  public var finishTimeMillis: Int64 {
    get {return _storage._finishTimeMillis}
    set {_uniqueStorage()._finishTimeMillis = newValue}
  }

  public var anomalyReport: BuildEventStream_BuildFinished.AnomalyReport {
    get {return _storage._anomalyReport ?? BuildEventStream_BuildFinished.AnomalyReport()}
    set {_uniqueStorage()._anomalyReport = newValue}
  }
  /// Returns true if `anomalyReport` has been explicitly set.
  public var hasAnomalyReport: Bool {return _storage._anomalyReport != nil}
  /// Clears the value of `anomalyReport`. Subsequent reads from it will return its default value.
  public mutating func clearAnomalyReport() {_uniqueStorage()._anomalyReport = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Exit code of a build. The possible values correspond to the predefined
  /// codes in bazel's lib.ExitCode class, as well as any custom exit code a
  /// module might define. The predefined exit codes are subject to change (but
  /// rarely do) and are not part of the public API.
  ///
  /// A build was successful iff ExitCode.code equals 0.
  public struct ExitCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the exit code.
    public var name: String = String()

    /// The exit code.
    public var code: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Things that happened during the build that could be of interest.
  public struct AnomalyReport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Was the build suspended at any time during the build.
    /// Examples of suspensions are SIGSTOP, or the hardware being put to sleep.
    /// If was_suspended is true, then most of the timings for this build are
    /// suspect.
    public var wasSuspended: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_BuildMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionSummary: BuildEventStream_BuildMetrics.ActionSummary {
    get {return _storage._actionSummary ?? BuildEventStream_BuildMetrics.ActionSummary()}
    set {_uniqueStorage()._actionSummary = newValue}
  }
  /// Returns true if `actionSummary` has been explicitly set.
  public var hasActionSummary: Bool {return _storage._actionSummary != nil}
  /// Clears the value of `actionSummary`. Subsequent reads from it will return its default value.
  public mutating func clearActionSummary() {_uniqueStorage()._actionSummary = nil}

  public var memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics {
    get {return _storage._memoryMetrics ?? BuildEventStream_BuildMetrics.MemoryMetrics()}
    set {_uniqueStorage()._memoryMetrics = newValue}
  }
  /// Returns true if `memoryMetrics` has been explicitly set.
  public var hasMemoryMetrics: Bool {return _storage._memoryMetrics != nil}
  /// Clears the value of `memoryMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearMemoryMetrics() {_uniqueStorage()._memoryMetrics = nil}

  public var targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics {
    get {return _storage._targetMetrics ?? BuildEventStream_BuildMetrics.TargetMetrics()}
    set {_uniqueStorage()._targetMetrics = newValue}
  }
  /// Returns true if `targetMetrics` has been explicitly set.
  public var hasTargetMetrics: Bool {return _storage._targetMetrics != nil}
  /// Clears the value of `targetMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTargetMetrics() {_uniqueStorage()._targetMetrics = nil}

  public var packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics {
    get {return _storage._packageMetrics ?? BuildEventStream_BuildMetrics.PackageMetrics()}
    set {_uniqueStorage()._packageMetrics = newValue}
  }
  /// Returns true if `packageMetrics` has been explicitly set.
  public var hasPackageMetrics: Bool {return _storage._packageMetrics != nil}
  /// Clears the value of `packageMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearPackageMetrics() {_uniqueStorage()._packageMetrics = nil}

  public var timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics {
    get {return _storage._timingMetrics ?? BuildEventStream_BuildMetrics.TimingMetrics()}
    set {_uniqueStorage()._timingMetrics = newValue}
  }
  /// Returns true if `timingMetrics` has been explicitly set.
  public var hasTimingMetrics: Bool {return _storage._timingMetrics != nil}
  /// Clears the value of `timingMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTimingMetrics() {_uniqueStorage()._timingMetrics = nil}

  public var cumulativeMetrics: BuildEventStream_BuildMetrics.CumulativeMetrics {
    get {return _storage._cumulativeMetrics ?? BuildEventStream_BuildMetrics.CumulativeMetrics()}
    set {_uniqueStorage()._cumulativeMetrics = newValue}
  }
  /// Returns true if `cumulativeMetrics` has been explicitly set.
  public var hasCumulativeMetrics: Bool {return _storage._cumulativeMetrics != nil}
  /// Clears the value of `cumulativeMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearCumulativeMetrics() {_uniqueStorage()._cumulativeMetrics = nil}

  public var artifactMetrics: BuildEventStream_BuildMetrics.ArtifactMetrics {
    get {return _storage._artifactMetrics ?? BuildEventStream_BuildMetrics.ArtifactMetrics()}
    set {_uniqueStorage()._artifactMetrics = newValue}
  }
  /// Returns true if `artifactMetrics` has been explicitly set.
  public var hasArtifactMetrics: Bool {return _storage._artifactMetrics != nil}
  /// Clears the value of `artifactMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearArtifactMetrics() {_uniqueStorage()._artifactMetrics = nil}

  public var buildGraphMetrics: BuildEventStream_BuildMetrics.BuildGraphMetrics {
    get {return _storage._buildGraphMetrics ?? BuildEventStream_BuildMetrics.BuildGraphMetrics()}
    set {_uniqueStorage()._buildGraphMetrics = newValue}
  }
  /// Returns true if `buildGraphMetrics` has been explicitly set.
  public var hasBuildGraphMetrics: Bool {return _storage._buildGraphMetrics != nil}
  /// Clears the value of `buildGraphMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearBuildGraphMetrics() {_uniqueStorage()._buildGraphMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ActionSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total number of actions created and registered during the build,
    /// including both aspects and configured targets. This metric includes
    /// unused actions that were constructed but not executed during this build.
    /// It does not include actions that were created on prior builds that are
    /// still valid, even if those actions had to be re-executed on this build.
    /// For the total number of actions that would be created if this invocation
    /// were "clean", see BuildGraphMetrics below.
    public var actionsCreated: Int64 = 0

    /// The total number of actions created this build just by configured
    /// targets. Used mainly to allow consumers of actions_created, which used to
    /// not include aspects' actions, to normalize across the Blaze release that
    /// switched actions_created to include all created actions.
    public var actionsCreatedNotIncludingAspects: Int64 = 0

    /// The total number of actions executed during the build. This includes any
    /// remote cache hits, but excludes local action cache hits.
    public var actionsExecuted: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MemoryMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Size of the JVM heap post build in bytes. This is only collected if
    /// --bep_publish_used_heap_size_post_build is set,
    /// since it forces a full GC.
    public var usedHeapSizePostBuild: Int64 = 0

    /// Size of the peak JVM heap size in bytes post GC. Note that this reports 0
    /// if there was no major GC during the build.
    public var peakPostGcHeapSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TargetMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// DEPRECATED
    /// No longer populated. It never measured what it was supposed to (targets
    /// loaded): it counted targets that were analyzed even if the underlying
    /// package had not changed.
    /// TODO(janakr): rename and remove.
    public var targetsLoaded: Int64 = 0

    /// Number of targets/aspects configured during this build. Does not include
    /// targets/aspects that were configured on prior builds on this server and
    /// were cached. See BuildGraphMetrics below if you need that.
    public var targetsConfigured: Int64 = 0

    /// Number of configured targets analyzed during this build. Does not include
    /// aspects. Used mainly to allow consumers of targets_configured, which used
    /// to not include aspects, to normalize across the Blaze release that
    /// switched targets_configured to include aspects.
    public var targetsConfiguredNotIncludingAspects: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PackageMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of BUILD files (aka packages) loaded during this build.
    public var packagesLoaded: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TimingMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The CPU time in milliseconds consumed during this build.
    public var cpuTimeInMs: Int64 = 0

    /// The elapsed wall time in milliseconds during this build.
    public var wallTimeInMs: Int64 = 0

    /// The elapsed wall time in milliseconds during the analysis phase.
    public var analysisPhaseTimeInMs: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CumulativeMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// One-indexed number of "analyses" the server has run, including the
    /// current one. Will be incremented for every build/test/cquery/etc. command
    /// that reaches the analysis phase.
    public var numAnalyses: Int32 = 0

    /// One-indexed number of "builds" the server has run, including the current
    /// one. Will be incremented for every build/test/run/etc. command that
    /// reaches the execution phase.
    public var numBuilds: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ArtifactMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Measures all source files newly read this build. Does not include
    /// unchanged sources on incremental builds.
    public var sourceArtifactsRead: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _storage._sourceArtifactsRead ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_uniqueStorage()._sourceArtifactsRead = newValue}
    }
    /// Returns true if `sourceArtifactsRead` has been explicitly set.
    public var hasSourceArtifactsRead: Bool {return _storage._sourceArtifactsRead != nil}
    /// Clears the value of `sourceArtifactsRead`. Subsequent reads from it will return its default value.
    public mutating func clearSourceArtifactsRead() {_uniqueStorage()._sourceArtifactsRead = nil}

    /// Measures all output artifacts from executed actions. This includes
    /// actions that were cached locally (via the action cache) or remotely (via
    /// a remote cache or executor), but does *not* include outputs of actions
    /// that were cached internally in Skyframe.
    public var outputArtifactsSeen: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _storage._outputArtifactsSeen ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_uniqueStorage()._outputArtifactsSeen = newValue}
    }
    /// Returns true if `outputArtifactsSeen` has been explicitly set.
    public var hasOutputArtifactsSeen: Bool {return _storage._outputArtifactsSeen != nil}
    /// Clears the value of `outputArtifactsSeen`. Subsequent reads from it will return its default value.
    public mutating func clearOutputArtifactsSeen() {_uniqueStorage()._outputArtifactsSeen = nil}

    /// Measures all output artifacts from actions that were cached locally
    /// via the action cache. These artifacts were already present on disk at the
    /// start of the build. Does not include Skyframe-cached actions' outputs.
    public var outputArtifactsFromActionCache: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _storage._outputArtifactsFromActionCache ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_uniqueStorage()._outputArtifactsFromActionCache = newValue}
    }
    /// Returns true if `outputArtifactsFromActionCache` has been explicitly set.
    public var hasOutputArtifactsFromActionCache: Bool {return _storage._outputArtifactsFromActionCache != nil}
    /// Clears the value of `outputArtifactsFromActionCache`. Subsequent reads from it will return its default value.
    public mutating func clearOutputArtifactsFromActionCache() {_uniqueStorage()._outputArtifactsFromActionCache = nil}

    /// Measures all artifacts that belong to a top-level output group. Does not
    /// deduplicate, so if there are two top-level targets in this build that
    /// share an artifact, it will be counted twice.
    public var topLevelArtifacts: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _storage._topLevelArtifacts ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_uniqueStorage()._topLevelArtifacts = newValue}
    }
    /// Returns true if `topLevelArtifacts` has been explicitly set.
    public var hasTopLevelArtifacts: Bool {return _storage._topLevelArtifacts != nil}
    /// Clears the value of `topLevelArtifacts`. Subsequent reads from it will return its default value.
    public mutating func clearTopLevelArtifacts() {_uniqueStorage()._topLevelArtifacts = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct FilesMetric {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var sizeInBytes: Int64 = 0

      public var count: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Information about the size and shape of the build graph. Some fields may
  /// not be populated if Bazel was able to skip steps due to caching.
  public struct BuildGraphMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How many configured targets/aspects were in this build, including any
    /// that were analyzed on a prior build and are still valid. May not be
    /// populated if analysis phase was fully cached.
    public var actionLookupValueCount: Int32 = 0

    /// How many configured targets alone were in this build: always at most
    /// action_lookup_value_count. Useful mainly for historical comparisons to
    /// TargetMetrics.targets_configured, which used to not count aspects.
    public var actionLookupValueCountNotIncludingAspects: Int32 = 0

    /// How many actions belonged to the configured targets/aspects above. It may
    /// not be necessary to execute all of these actions to build the requested
    /// targets. May not be populated if analysis phase was fully cached.
    public var actionCount: Int32 = 0

    /// How many actions belonged to configured targets: always at most
    /// action_count. Useful mainly for historical comparisons to
    /// ActionMetrics.actions_created, which used to not count aspects' actions.
    public var actionCountNotIncludingAspects: Int32 = 0

    /// How many artifacts are outputs of the above actions. May not be populated
    /// if analysis phase was fully cached.
    public var outputArtifactCount: Int32 = 0

    /// How many Skyframe nodes there are in memory at the end of the build. This
    /// may underestimate the number of nodes when running with memory-saving
    /// settings or with Skybuild, and may overestimate if there are nodes from
    /// prior evaluations still in the cache.
    public var postInvocationSkyframeNodeCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Event providing additional statistics/logs after completion of the build.
public struct BuildEventStream_BuildToolLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var log: [BuildEventStream_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event describing all convenience symlinks (i.e., workspace symlinks) to be
/// created or deleted once the execution phase has begun. Note that this event
/// does not say anything about whether or not the build tool actually executed
/// these filesystem operations; it only says what logical operations should be
/// performed. This event is emitted exactly once per build; if no symlinks are
/// to be modified, the event is still emitted with empty contents.
public struct BuildEventStream_ConvenienceSymlinksIdentified {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var convenienceSymlinks: [BuildEventStream_ConvenienceSymlink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message that contains what type of action to perform on a given path and
/// target of a symlink.
public struct BuildEventStream_ConvenienceSymlink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path of the symlink to be created or deleted, absolute or relative to
  /// the workspace, creating any directories necessary. If a symlink already
  /// exists at that location, then it should be replaced by a symlink pointing
  /// to the new target.
  public var path: String = String()

  /// The operation we are performing on the symlink.
  public var action: BuildEventStream_ConvenienceSymlink.Action = .unknown

  /// If action is CREATE, this is the target path that the symlink should point
  /// to. If the path points underneath the output base, it is relative to the
  /// output base; otherwise it is absolute.
  ///
  /// If action is DELETE, this field is not set.
  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Indicates a symlink should be created, or overwritten if it already
    /// exists.
    case create // = 1

    /// Indicates a symlink should be deleted if it already exists.
    case delete // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .create
      case 2: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .create: return 1
      case .delete: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_ConvenienceSymlink.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_ConvenienceSymlink.Action] = [
    .unknown,
    .create,
    .delete,
  ]
}

#endif  // swift(>=4.2)

/// Message describing a build event. Events will have an identifier that
/// is unique within a given build invocation; they also announce follow-up
/// events as children. More details, which are specific to the kind of event
/// that is observed, is provided in the payload. More options for the payload
/// might be added in the future.
public struct BuildEventStream_BuildEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId {
    get {return _storage._id ?? BuildEventStream_BuildEventId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var children: [BuildEventStream_BuildEventId] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var lastMessage: Bool {
    get {return _storage._lastMessage}
    set {_uniqueStorage()._lastMessage = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var progress: BuildEventStream_Progress {
    get {
      if case .progress(let v)? = _storage._payload {return v}
      return BuildEventStream_Progress()
    }
    set {_uniqueStorage()._payload = .progress(newValue)}
  }

  public var aborted: BuildEventStream_Aborted {
    get {
      if case .aborted(let v)? = _storage._payload {return v}
      return BuildEventStream_Aborted()
    }
    set {_uniqueStorage()._payload = .aborted(newValue)}
  }

  public var started: BuildEventStream_BuildStarted {
    get {
      if case .started(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildStarted()
    }
    set {_uniqueStorage()._payload = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_UnstructuredCommandLine {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._payload {return v}
      return BuildEventStream_UnstructuredCommandLine()
    }
    set {_uniqueStorage()._payload = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: CommandLine_CommandLine {
    get {
      if case .structuredCommandLine(let v)? = _storage._payload {return v}
      return CommandLine_CommandLine()
    }
    set {_uniqueStorage()._payload = .structuredCommandLine(newValue)}
  }

  public var optionsParsed: BuildEventStream_OptionsParsed {
    get {
      if case .optionsParsed(let v)? = _storage._payload {return v}
      return BuildEventStream_OptionsParsed()
    }
    set {_uniqueStorage()._payload = .optionsParsed(newValue)}
  }

  public var workspaceStatus: BuildEventStream_WorkspaceStatus {
    get {
      if case .workspaceStatus(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceStatus()
    }
    set {_uniqueStorage()._payload = .workspaceStatus(newValue)}
  }

  public var fetch: BuildEventStream_Fetch {
    get {
      if case .fetch(let v)? = _storage._payload {return v}
      return BuildEventStream_Fetch()
    }
    set {_uniqueStorage()._payload = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_Configuration {
    get {
      if case .configuration(let v)? = _storage._payload {return v}
      return BuildEventStream_Configuration()
    }
    set {_uniqueStorage()._payload = .configuration(newValue)}
  }

  public var expanded: BuildEventStream_PatternExpanded {
    get {
      if case .expanded(let v)? = _storage._payload {return v}
      return BuildEventStream_PatternExpanded()
    }
    set {_uniqueStorage()._payload = .expanded(newValue)}
  }

  public var configured: BuildEventStream_TargetConfigured {
    get {
      if case .configured(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetConfigured()
    }
    set {_uniqueStorage()._payload = .configured(newValue)}
  }

  public var action: BuildEventStream_ActionExecuted {
    get {
      if case .action(let v)? = _storage._payload {return v}
      return BuildEventStream_ActionExecuted()
    }
    set {_uniqueStorage()._payload = .action(newValue)}
  }

  public var namedSetOfFiles: BuildEventStream_NamedSetOfFiles {
    get {
      if case .namedSetOfFiles(let v)? = _storage._payload {return v}
      return BuildEventStream_NamedSetOfFiles()
    }
    set {_uniqueStorage()._payload = .namedSetOfFiles(newValue)}
  }

  public var completed: BuildEventStream_TargetComplete {
    get {
      if case .completed(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetComplete()
    }
    set {_uniqueStorage()._payload = .completed(newValue)}
  }

  public var testResult: BuildEventStream_TestResult {
    get {
      if case .testResult(let v)? = _storage._payload {return v}
      return BuildEventStream_TestResult()
    }
    set {_uniqueStorage()._payload = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_TestSummary {
    get {
      if case .testSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TestSummary()
    }
    set {_uniqueStorage()._payload = .testSummary(newValue)}
  }

  public var targetSummary: BuildEventStream_TargetSummary {
    get {
      if case .targetSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetSummary()
    }
    set {_uniqueStorage()._payload = .targetSummary(newValue)}
  }

  public var finished: BuildEventStream_BuildFinished {
    get {
      if case .finished(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildFinished()
    }
    set {_uniqueStorage()._payload = .finished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildToolLogs {
    get {
      if case .buildToolLogs(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildToolLogs()
    }
    set {_uniqueStorage()._payload = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildMetrics {
    get {
      if case .buildMetrics(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetrics()
    }
    set {_uniqueStorage()._payload = .buildMetrics(newValue)}
  }

  public var workspaceInfo: BuildEventStream_WorkspaceConfig {
    get {
      if case .workspaceInfo(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceConfig()
    }
    set {_uniqueStorage()._payload = .workspaceInfo(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildMetadata {
    get {
      if case .buildMetadata(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetadata()
    }
    set {_uniqueStorage()._payload = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_ConvenienceSymlinksIdentified {
    get {
      if case .convenienceSymlinksIdentified(let v)? = _storage._payload {return v}
      return BuildEventStream_ConvenienceSymlinksIdentified()
    }
    set {_uniqueStorage()._payload = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case progress(BuildEventStream_Progress)
    case aborted(BuildEventStream_Aborted)
    case started(BuildEventStream_BuildStarted)
    case unstructuredCommandLine(BuildEventStream_UnstructuredCommandLine)
    case structuredCommandLine(CommandLine_CommandLine)
    case optionsParsed(BuildEventStream_OptionsParsed)
    case workspaceStatus(BuildEventStream_WorkspaceStatus)
    case fetch(BuildEventStream_Fetch)
    case configuration(BuildEventStream_Configuration)
    case expanded(BuildEventStream_PatternExpanded)
    case configured(BuildEventStream_TargetConfigured)
    case action(BuildEventStream_ActionExecuted)
    case namedSetOfFiles(BuildEventStream_NamedSetOfFiles)
    case completed(BuildEventStream_TargetComplete)
    case testResult(BuildEventStream_TestResult)
    case testSummary(BuildEventStream_TestSummary)
    case targetSummary(BuildEventStream_TargetSummary)
    case finished(BuildEventStream_BuildFinished)
    case buildToolLogs(BuildEventStream_BuildToolLogs)
    case buildMetrics(BuildEventStream_BuildMetrics)
    case workspaceInfo(BuildEventStream_WorkspaceConfig)
    case buildMetadata(BuildEventStream_BuildMetadata)
    case convenienceSymlinksIdentified(BuildEventStream_ConvenienceSymlinksIdentified)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEvent.OneOf_Payload, rhs: BuildEventStream_BuildEvent.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.progress(let l), .progress(let r)): return l == r
      case (.aborted(let l), .aborted(let r)): return l == r
      case (.started(let l), .started(let r)): return l == r
      case (.unstructuredCommandLine(let l), .unstructuredCommandLine(let r)): return l == r
      case (.structuredCommandLine(let l), .structuredCommandLine(let r)): return l == r
      case (.optionsParsed(let l), .optionsParsed(let r)): return l == r
      case (.workspaceStatus(let l), .workspaceStatus(let r)): return l == r
      case (.fetch(let l), .fetch(let r)): return l == r
      case (.configuration(let l), .configuration(let r)): return l == r
      case (.expanded(let l), .expanded(let r)): return l == r
      case (.configured(let l), .configured(let r)): return l == r
      case (.action(let l), .action(let r)): return l == r
      case (.namedSetOfFiles(let l), .namedSetOfFiles(let r)): return l == r
      case (.completed(let l), .completed(let r)): return l == r
      case (.testResult(let l), .testResult(let r)): return l == r
      case (.testSummary(let l), .testSummary(let r)): return l == r
      case (.targetSummary(let l), .targetSummary(let r)): return l == r
      case (.finished(let l), .finished(let r)): return l == r
      case (.buildToolLogs(let l), .buildToolLogs(let r)): return l == r
      case (.buildMetrics(let l), .buildMetrics(let r)): return l == r
      case (.workspaceInfo(let l), .workspaceInfo(let r)): return l == r
      case (.buildMetadata(let l), .buildMetadata(let r)): return l == r
      case (.convenienceSymlinksIdentified(let l), .convenienceSymlinksIdentified(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build_event_stream"

extension BuildEventStream_TestSize: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SMALL"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "LARGE"),
    4: .same(proto: "ENORMOUS"),
  ]
}

extension BuildEventStream_TestStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_STATUS"),
    1: .same(proto: "PASSED"),
    2: .same(proto: "FLAKY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "INCOMPLETE"),
    6: .same(proto: "REMOTE_FAILURE"),
    7: .same(proto: "FAILED_TO_BUILD"),
    8: .same(proto: "TOOL_HALTED_BEFORE_TESTING"),
  ]
}

extension BuildEventStream_BuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "progress"),
    3: .same(proto: "started"),
    11: .standard(proto: "unstructured_command_line"),
    18: .standard(proto: "structured_command_line"),
    14: .standard(proto: "workspace_status"),
    12: .standard(proto: "options_parsed"),
    17: .same(proto: "fetch"),
    15: .same(proto: "configuration"),
    16: .standard(proto: "target_configured"),
    4: .same(proto: "pattern"),
    10: .standard(proto: "pattern_skipped"),
    13: .standard(proto: "named_set"),
    5: .standard(proto: "target_completed"),
    6: .standard(proto: "action_completed"),
    19: .standard(proto: "unconfigured_label"),
    21: .standard(proto: "configured_label"),
    8: .standard(proto: "test_result"),
    7: .standard(proto: "test_summary"),
    26: .standard(proto: "target_summary"),
    9: .standard(proto: "build_finished"),
    20: .standard(proto: "build_tool_logs"),
    22: .standard(proto: "build_metrics"),
    23: .same(proto: "workspace"),
    24: .standard(proto: "build_metadata"),
    25: .standard(proto: "convenience_symlinks_identified"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: BuildEventStream_BuildEventId.UnknownBuildEventId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unknown(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unknown(v)}
        case 2:
          var v: BuildEventStream_BuildEventId.ProgressId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .progress(v)}
        case 3:
          var v: BuildEventStream_BuildEventId.BuildStartedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .started(v)}
        case 4:
          var v: BuildEventStream_BuildEventId.PatternExpandedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .pattern(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .pattern(v)}
        case 5:
          var v: BuildEventStream_BuildEventId.TargetCompletedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetCompleted(v)}
        case 6:
          var v: BuildEventStream_BuildEventId.ActionCompletedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .actionCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .actionCompleted(v)}
        case 7:
          var v: BuildEventStream_BuildEventId.TestSummaryId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .testSummary(v)}
        case 8:
          var v: BuildEventStream_BuildEventId.TestResultId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .testResult(v)}
        case 9:
          var v: BuildEventStream_BuildEventId.BuildFinishedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildFinished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildFinished(v)}
        case 10:
          var v: BuildEventStream_BuildEventId.PatternExpandedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .patternSkipped(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .patternSkipped(v)}
        case 11:
          var v: BuildEventStream_BuildEventId.UnstructuredCommandLineId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unstructuredCommandLine(v)}
        case 12:
          var v: BuildEventStream_BuildEventId.OptionsParsedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .optionsParsed(v)}
        case 13:
          var v: BuildEventStream_BuildEventId.NamedSetOfFilesId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .namedSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .namedSet(v)}
        case 14:
          var v: BuildEventStream_BuildEventId.WorkspaceStatusId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .workspaceStatus(v)}
        case 15:
          var v: BuildEventStream_BuildEventId.ConfigurationId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .configuration(v)}
        case 16:
          var v: BuildEventStream_BuildEventId.TargetConfiguredId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetConfigured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetConfigured(v)}
        case 17:
          var v: BuildEventStream_BuildEventId.FetchId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .fetch(v)}
        case 18:
          var v: BuildEventStream_BuildEventId.StructuredCommandLineId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .structuredCommandLine(v)}
        case 19:
          var v: BuildEventStream_BuildEventId.UnconfiguredLabelId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unconfiguredLabel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unconfiguredLabel(v)}
        case 20:
          var v: BuildEventStream_BuildEventId.BuildToolLogsId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildToolLogs(v)}
        case 21:
          var v: BuildEventStream_BuildEventId.ConfiguredLabelId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .configuredLabel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .configuredLabel(v)}
        case 22:
          var v: BuildEventStream_BuildEventId.BuildMetricsId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildMetrics(v)}
        case 23:
          var v: BuildEventStream_BuildEventId.WorkspaceConfigId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .workspace(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .workspace(v)}
        case 24:
          var v: BuildEventStream_BuildEventId.BuildMetadataId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildMetadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildMetadata(v)}
        case 25:
          var v: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .convenienceSymlinksIdentified(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .convenienceSymlinksIdentified(v)}
        case 26:
          var v: BuildEventStream_BuildEventId.TargetSummaryId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetSummary(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._id {
      case .unknown(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .progress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .started(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .pattern(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .targetCompleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .actionCompleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .testSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .testResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .buildFinished(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .patternSkipped(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .unstructuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .optionsParsed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .namedSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .workspaceStatus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .configuration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .targetConfigured(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .fetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .structuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .unconfiguredLabel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .buildToolLogs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .configuredLabel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .buildMetrics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .workspace(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .buildMetadata(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .convenienceSymlinksIdentified(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .targetSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId, rhs: BuildEventStream_BuildEventId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnknownBuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnknownBuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.details)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnknownBuildEventId, rhs: BuildEventStream_BuildEventId.UnknownBuildEventId) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ProgressId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ProgressId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opaque_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.opaqueCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.opaqueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.opaqueCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ProgressId, rhs: BuildEventStream_BuildEventId.ProgressId) -> Bool {
    if lhs.opaqueCount != rhs.opaqueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildStartedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildStartedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildStartedId, rhs: BuildEventStream_BuildEventId.BuildStartedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnstructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnstructuredCommandLineId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId, rhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.StructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".StructuredCommandLineId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_line_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.commandLineLabel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandLineLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.commandLineLabel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.StructuredCommandLineId, rhs: BuildEventStream_BuildEventId.StructuredCommandLineId) -> Bool {
    if lhs.commandLineLabel != rhs.commandLineLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceStatusId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceStatusId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceStatusId, rhs: BuildEventStream_BuildEventId.WorkspaceStatusId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.OptionsParsedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".OptionsParsedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.OptionsParsedId, rhs: BuildEventStream_BuildEventId.OptionsParsedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.FetchId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".FetchId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.FetchId, rhs: BuildEventStream_BuildEventId.FetchId) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.PatternExpandedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".PatternExpandedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.pattern)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.PatternExpandedId, rhs: BuildEventStream_BuildEventId.PatternExpandedId) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceConfigId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceConfigId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceConfigId, rhs: BuildEventStream_BuildEventId.WorkspaceConfigId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetadataId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetadataId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetadataId, rhs: BuildEventStream_BuildEventId.BuildMetadataId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetConfiguredId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetConfiguredId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      case 2: try decoder.decodeSingularStringField(value: &self.aspect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetConfiguredId, rhs: BuildEventStream_BuildEventId.TargetConfiguredId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.NamedSetOfFilesId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".NamedSetOfFilesId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.NamedSetOfFilesId, rhs: BuildEventStream_BuildEventId.NamedSetOfFilesId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfigurationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfigurationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfigurationId, rhs: BuildEventStream_BuildEventId.ConfigurationId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    3: .same(proto: "configuration"),
    2: .same(proto: "aspect"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _aspect: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
      _aspect = source._aspect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularStringField(value: &_storage._aspect)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if !_storage._aspect.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aspect, fieldNumber: 2)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetCompletedId, rhs: BuildEventStream_BuildEventId.TargetCompletedId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._aspect != rhs_storage._aspect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ActionCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ActionCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_output"),
    2: .same(proto: "label"),
    3: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _primaryOutput: String = String()
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _primaryOutput = source._primaryOutput
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._primaryOutput)
        case 2: try decoder.decodeSingularStringField(value: &_storage._label)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._primaryOutput.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryOutput, fieldNumber: 1)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 2)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ActionCompletedId, rhs: BuildEventStream_BuildEventId.ActionCompletedId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnconfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnconfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnconfiguredLabelId, rhs: BuildEventStream_BuildEventId.UnconfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfiguredLabelId, rhs: BuildEventStream_BuildEventId.ConfiguredLabelId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestResultId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestResultId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    5: .same(proto: "configuration"),
    2: .same(proto: "run"),
    3: .same(proto: "shard"),
    4: .same(proto: "attempt"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _run: Int32 = 0
    var _shard: Int32 = 0
    var _attempt: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
      _run = source._run
      _shard = source._shard
      _attempt = source._attempt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._run)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._shard)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._attempt)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if _storage._run != 0 {
        try visitor.visitSingularInt32Field(value: _storage._run, fieldNumber: 2)
      }
      if _storage._shard != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shard, fieldNumber: 3)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 4)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestResultId, rhs: BuildEventStream_BuildEventId.TestResultId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._run != rhs_storage._run {return false}
        if _storage._shard != rhs_storage._shard {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestSummaryId, rhs: BuildEventStream_BuildEventId.TestSummaryId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetSummaryId, rhs: BuildEventStream_BuildEventId.TargetSummaryId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildFinishedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildFinishedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildFinishedId, rhs: BuildEventStream_BuildEventId.BuildFinishedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildToolLogsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildToolLogsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildToolLogsId, rhs: BuildEventStream_BuildEventId.BuildToolLogsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetricsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetricsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetricsId, rhs: BuildEventStream_BuildEventId.BuildMetricsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConvenienceSymlinksIdentifiedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId, rhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.stdout)
      case 2: try decoder.decodeSingularStringField(value: &self.stderr)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stdout.isEmpty {
      try visitor.visitSingularStringField(value: self.stdout, fieldNumber: 1)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularStringField(value: self.stderr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Progress, rhs: BuildEventStream_Progress) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aborted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Aborted, rhs: BuildEventStream_Aborted) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted.AbortReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "USER_INTERRUPTED"),
    2: .same(proto: "TIME_OUT"),
    3: .same(proto: "REMOTE_ENVIRONMENT_FAILURE"),
    4: .same(proto: "INTERNAL"),
    5: .same(proto: "LOADING_FAILURE"),
    6: .same(proto: "ANALYSIS_FAILURE"),
    7: .same(proto: "SKIPPED"),
    8: .same(proto: "NO_ANALYZE"),
    9: .same(proto: "NO_BUILD"),
    10: .same(proto: "INCOMPLETE"),
    11: .same(proto: "OUT_OF_MEMORY"),
  ]
}

extension BuildEventStream_BuildStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildStarted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "start_time_millis"),
    3: .standard(proto: "build_tool_version"),
    4: .standard(proto: "options_description"),
    5: .same(proto: "command"),
    6: .standard(proto: "working_directory"),
    7: .standard(proto: "workspace_directory"),
    8: .standard(proto: "server_pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uuid)
      case 2: try decoder.decodeSingularInt64Field(value: &self.startTimeMillis)
      case 3: try decoder.decodeSingularStringField(value: &self.buildToolVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.optionsDescription)
      case 5: try decoder.decodeSingularStringField(value: &self.command)
      case 6: try decoder.decodeSingularStringField(value: &self.workingDirectory)
      case 7: try decoder.decodeSingularStringField(value: &self.workspaceDirectory)
      case 8: try decoder.decodeSingularInt64Field(value: &self.serverPid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.startTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeMillis, fieldNumber: 2)
    }
    if !self.buildToolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.buildToolVersion, fieldNumber: 3)
    }
    if !self.optionsDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.optionsDescription, fieldNumber: 4)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 5)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 6)
    }
    if !self.workspaceDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDirectory, fieldNumber: 7)
    }
    if self.serverPid != 0 {
      try visitor.visitSingularInt64Field(value: self.serverPid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildStarted, rhs: BuildEventStream_BuildStarted) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.startTimeMillis != rhs.startTimeMillis {return false}
    if lhs.buildToolVersion != rhs.buildToolVersion {return false}
    if lhs.optionsDescription != rhs.optionsDescription {return false}
    if lhs.command != rhs.command {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.workspaceDirectory != rhs.workspaceDirectory {return false}
    if lhs.serverPid != rhs.serverPid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_exec_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.localExecRoot)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localExecRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.localExecRoot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceConfig, rhs: BuildEventStream_WorkspaceConfig) -> Bool {
    if lhs.localExecRoot != rhs.localExecRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_UnstructuredCommandLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnstructuredCommandLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.args)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_UnstructuredCommandLine, rhs: BuildEventStream_UnstructuredCommandLine) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OptionsParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionsParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "startup_options"),
    2: .standard(proto: "explicit_startup_options"),
    3: .standard(proto: "cmd_line"),
    4: .standard(proto: "explicit_cmd_line"),
    5: .standard(proto: "invocation_policy"),
    6: .standard(proto: "tool_tag"),
  ]

  fileprivate class _StorageClass {
    var _startupOptions: [String] = []
    var _explicitStartupOptions: [String] = []
    var _cmdLine: [String] = []
    var _explicitCmdLine: [String] = []
    var _invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy? = nil
    var _toolTag: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startupOptions = source._startupOptions
      _explicitStartupOptions = source._explicitStartupOptions
      _cmdLine = source._cmdLine
      _explicitCmdLine = source._explicitCmdLine
      _invocationPolicy = source._invocationPolicy
      _toolTag = source._toolTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._startupOptions)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._explicitStartupOptions)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._cmdLine)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._explicitCmdLine)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._invocationPolicy)
        case 6: try decoder.decodeSingularStringField(value: &_storage._toolTag)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._startupOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._startupOptions, fieldNumber: 1)
      }
      if !_storage._explicitStartupOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._explicitStartupOptions, fieldNumber: 2)
      }
      if !_storage._cmdLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cmdLine, fieldNumber: 3)
      }
      if !_storage._explicitCmdLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._explicitCmdLine, fieldNumber: 4)
      }
      if let v = _storage._invocationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._toolTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toolTag, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OptionsParsed, rhs: BuildEventStream_OptionsParsed) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startupOptions != rhs_storage._startupOptions {return false}
        if _storage._explicitStartupOptions != rhs_storage._explicitStartupOptions {return false}
        if _storage._cmdLine != rhs_storage._cmdLine {return false}
        if _storage._explicitCmdLine != rhs_storage._explicitCmdLine {return false}
        if _storage._invocationPolicy != rhs_storage._invocationPolicy {return false}
        if _storage._toolTag != rhs_storage._toolTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Fetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fetch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Fetch, rhs: BuildEventStream_Fetch) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.item)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus, rhs: BuildEventStream_WorkspaceStatus) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_WorkspaceStatus.protoMessageName + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus.Item, rhs: BuildEventStream_WorkspaceStatus.Item) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetadata, rhs: BuildEventStream_BuildMetadata) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "platform_name"),
    3: .same(proto: "cpu"),
    4: .standard(proto: "make_variable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.mnemonic)
      case 2: try decoder.decodeSingularStringField(value: &self.platformName)
      case 3: try decoder.decodeSingularStringField(value: &self.cpu)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.makeVariable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 2)
    }
    if !self.cpu.isEmpty {
      try visitor.visitSingularStringField(value: self.cpu, fieldNumber: 3)
    }
    if !self.makeVariable.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.makeVariable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Configuration, rhs: BuildEventStream_Configuration) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.cpu != rhs.cpu {return false}
    if lhs.makeVariable != rhs.makeVariable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatternExpanded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_suite_expansions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.testSuiteExpansions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.testSuiteExpansions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.testSuiteExpansions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded, rhs: BuildEventStream_PatternExpanded) -> Bool {
    if lhs.testSuiteExpansions != rhs.testSuiteExpansions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded.TestSuiteExpansion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_PatternExpanded.protoMessageName + ".TestSuiteExpansion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suite_label"),
    2: .standard(proto: "test_labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.suiteLabel)
      case 2: try decoder.decodeRepeatedStringField(value: &self.testLabels)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suiteLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.suiteLabel, fieldNumber: 1)
    }
    if !self.testLabels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.testLabels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded.TestSuiteExpansion, rhs: BuildEventStream_PatternExpanded.TestSuiteExpansion) -> Bool {
    if lhs.suiteLabel != rhs.suiteLabel {return false}
    if lhs.testLabels != rhs.testLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetConfigured"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_kind"),
    2: .standard(proto: "test_size"),
    3: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.targetKind)
      case 2: try decoder.decodeSingularEnumField(value: &self.testSize)
      case 3: try decoder.decodeRepeatedStringField(value: &self.tag)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 1)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetConfigured, rhs: BuildEventStream_TargetConfigured) -> Bool {
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "path_prefix"),
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
    3: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2:
        if self.file != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.file = .uri(v)}
      case 3:
        if self.file != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.file = .contents(v)}
      case 4: try decoder.decodeRepeatedStringField(value: &self.pathPrefix)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.file {
    case .uri(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .contents(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case nil: break
    }
    if !self.pathPrefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pathPrefix, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_File, rhs: BuildEventStream_File) -> Bool {
    if lhs.pathPrefix != rhs.pathPrefix {return false}
    if lhs.name != rhs.name {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_NamedSetOfFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedSetOfFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.files)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.fileSets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_NamedSetOfFiles, rhs: BuildEventStream_NamedSetOfFiles) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ActionExecuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionExecuted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    8: .same(proto: "type"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "stdout"),
    4: .same(proto: "stderr"),
    5: .same(proto: "label"),
    7: .same(proto: "configuration"),
    6: .standard(proto: "primary_output"),
    9: .standard(proto: "command_line"),
    10: .standard(proto: "action_metadata_logs"),
    11: .standard(proto: "failure_detail"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _type: String = String()
    var _exitCode: Int32 = 0
    var _stdout: BuildEventStream_File? = nil
    var _stderr: BuildEventStream_File? = nil
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _primaryOutput: BuildEventStream_File? = nil
    var _commandLine: [String] = []
    var _actionMetadataLogs: [BuildEventStream_File] = []
    var _failureDetail: FailureDetails_FailureDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _type = source._type
      _exitCode = source._exitCode
      _stdout = source._stdout
      _stderr = source._stderr
      _label = source._label
      _configuration = source._configuration
      _primaryOutput = source._primaryOutput
      _commandLine = source._commandLine
      _actionMetadataLogs = source._actionMetadataLogs
      _failureDetail = source._failureDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._success)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._stdout)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._stderr)
        case 5: try decoder.decodeSingularStringField(value: &_storage._label)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._primaryOutput)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        case 8: try decoder.decodeSingularStringField(value: &_storage._type)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._commandLine)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._actionMetadataLogs)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._failureDetail)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 2)
      }
      if let v = _storage._stdout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._stderr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 5)
      }
      if let v = _storage._primaryOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._commandLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandLine, fieldNumber: 9)
      }
      if !_storage._actionMetadataLogs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionMetadataLogs, fieldNumber: 10)
      }
      if let v = _storage._failureDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ActionExecuted, rhs: BuildEventStream_ActionExecuted) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._stdout != rhs_storage._stdout {return false}
        if _storage._stderr != rhs_storage._stderr {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._commandLine != rhs_storage._commandLine {return false}
        if _storage._actionMetadataLogs != rhs_storage._actionMetadataLogs {return false}
        if _storage._failureDetail != rhs_storage._failureDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OutputGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.fileSets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OutputGroup, rhs: BuildEventStream_OutputGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetComplete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    5: .standard(proto: "target_kind"),
    6: .standard(proto: "test_size"),
    2: .standard(proto: "output_group"),
    4: .standard(proto: "important_output"),
    8: .standard(proto: "directory_output"),
    3: .same(proto: "tag"),
    7: .standard(proto: "test_timeout_seconds"),
    9: .standard(proto: "failure_detail"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _targetKind: String = String()
    var _testSize: BuildEventStream_TestSize = .unknown
    var _outputGroup: [BuildEventStream_OutputGroup] = []
    var _importantOutput: [BuildEventStream_File] = []
    var _directoryOutput: [BuildEventStream_File] = []
    var _tag: [String] = []
    var _testTimeoutSeconds: Int64 = 0
    var _failureDetail: FailureDetails_FailureDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _targetKind = source._targetKind
      _testSize = source._testSize
      _outputGroup = source._outputGroup
      _importantOutput = source._importantOutput
      _directoryOutput = source._directoryOutput
      _tag = source._tag
      _testTimeoutSeconds = source._testTimeoutSeconds
      _failureDetail = source._failureDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._success)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._outputGroup)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._tag)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._importantOutput)
        case 5: try decoder.decodeSingularStringField(value: &_storage._targetKind)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._testSize)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._testTimeoutSeconds)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._directoryOutput)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._failureDetail)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if !_storage._outputGroup.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputGroup, fieldNumber: 2)
      }
      if !_storage._tag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tag, fieldNumber: 3)
      }
      if !_storage._importantOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._importantOutput, fieldNumber: 4)
      }
      if !_storage._targetKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetKind, fieldNumber: 5)
      }
      if _storage._testSize != .unknown {
        try visitor.visitSingularEnumField(value: _storage._testSize, fieldNumber: 6)
      }
      if _storage._testTimeoutSeconds != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testTimeoutSeconds, fieldNumber: 7)
      }
      if !_storage._directoryOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._directoryOutput, fieldNumber: 8)
      }
      if let v = _storage._failureDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetComplete, rhs: BuildEventStream_TargetComplete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._targetKind != rhs_storage._targetKind {return false}
        if _storage._testSize != rhs_storage._testSize {return false}
        if _storage._outputGroup != rhs_storage._outputGroup {return false}
        if _storage._importantOutput != rhs_storage._importantOutput {return false}
        if _storage._directoryOutput != rhs_storage._directoryOutput {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._testTimeoutSeconds != rhs_storage._testTimeoutSeconds {return false}
        if _storage._failureDetail != rhs_storage._failureDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "status"),
    9: .standard(proto: "status_details"),
    4: .standard(proto: "cached_locally"),
    6: .standard(proto: "test_attempt_start_millis_epoch"),
    3: .standard(proto: "test_attempt_duration_millis"),
    2: .standard(proto: "test_action_output"),
    7: .same(proto: "warning"),
    8: .standard(proto: "execution_info"),
  ]

  fileprivate class _StorageClass {
    var _status: BuildEventStream_TestStatus = .noStatus
    var _statusDetails: String = String()
    var _cachedLocally: Bool = false
    var _testAttemptStartMillisEpoch: Int64 = 0
    var _testAttemptDurationMillis: Int64 = 0
    var _testActionOutput: [BuildEventStream_File] = []
    var _warning: [String] = []
    var _executionInfo: BuildEventStream_TestResult.ExecutionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _statusDetails = source._statusDetails
      _cachedLocally = source._cachedLocally
      _testAttemptStartMillisEpoch = source._testAttemptStartMillisEpoch
      _testAttemptDurationMillis = source._testAttemptDurationMillis
      _testActionOutput = source._testActionOutput
      _warning = source._warning
      _executionInfo = source._executionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._testActionOutput)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._testAttemptDurationMillis)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._cachedLocally)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._testAttemptStartMillisEpoch)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._warning)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._executionInfo)
        case 9: try decoder.decodeSingularStringField(value: &_storage._statusDetails)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._testActionOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testActionOutput, fieldNumber: 2)
      }
      if _storage._testAttemptDurationMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptDurationMillis, fieldNumber: 3)
      }
      if _storage._cachedLocally != false {
        try visitor.visitSingularBoolField(value: _storage._cachedLocally, fieldNumber: 4)
      }
      if _storage._status != .noStatus {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._testAttemptStartMillisEpoch != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptStartMillisEpoch, fieldNumber: 6)
      }
      if !_storage._warning.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._warning, fieldNumber: 7)
      }
      if let v = _storage._executionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._statusDetails.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusDetails, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult, rhs: BuildEventStream_TestResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusDetails != rhs_storage._statusDetails {return false}
        if _storage._cachedLocally != rhs_storage._cachedLocally {return false}
        if _storage._testAttemptStartMillisEpoch != rhs_storage._testAttemptStartMillisEpoch {return false}
        if _storage._testAttemptDurationMillis != rhs_storage._testAttemptDurationMillis {return false}
        if _storage._testActionOutput != rhs_storage._testActionOutput {return false}
        if _storage._warning != rhs_storage._warning {return false}
        if _storage._executionInfo != rhs_storage._executionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.protoMessageName + ".ExecutionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_seconds"),
    2: .same(proto: "strategy"),
    6: .standard(proto: "cached_remotely"),
    7: .standard(proto: "exit_code"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "timing_breakdown"),
    5: .standard(proto: "resource_usage"),
  ]

  fileprivate class _StorageClass {
    var _timeoutSeconds: Int32 = 0
    var _strategy: String = String()
    var _cachedRemotely: Bool = false
    var _exitCode: Int32 = 0
    var _hostname: String = String()
    var _timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown? = nil
    var _resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timeoutSeconds = source._timeoutSeconds
      _strategy = source._strategy
      _cachedRemotely = source._cachedRemotely
      _exitCode = source._exitCode
      _hostname = source._hostname
      _timingBreakdown = source._timingBreakdown
      _resourceUsage = source._resourceUsage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds)
        case 2: try decoder.decodeSingularStringField(value: &_storage._strategy)
        case 3: try decoder.decodeSingularStringField(value: &_storage._hostname)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._timingBreakdown)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._resourceUsage)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._cachedRemotely)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._timeoutSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timeoutSeconds, fieldNumber: 1)
      }
      if !_storage._strategy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._strategy, fieldNumber: 2)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 3)
      }
      if let v = _storage._timingBreakdown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._resourceUsage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._resourceUsage, fieldNumber: 5)
      }
      if _storage._cachedRemotely != false {
        try visitor.visitSingularBoolField(value: _storage._cachedRemotely, fieldNumber: 6)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo, rhs: BuildEventStream_TestResult.ExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._cachedRemotely != rhs_storage._cachedRemotely {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._timingBreakdown != rhs_storage._timingBreakdown {return false}
        if _storage._resourceUsage != rhs_storage._resourceUsage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".TimingBreakdown"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "child"),
    2: .same(proto: "name"),
    3: .standard(proto: "time_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.child)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timeMillis)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.timeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.timeMillis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown, rhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs.name != rhs.name {return false}
    if lhs.timeMillis != rhs.timeMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".ResourceUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage, rhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "overall_status"),
    1: .standard(proto: "total_run_count"),
    10: .standard(proto: "run_count"),
    11: .standard(proto: "shard_count"),
    3: .same(proto: "passed"),
    4: .same(proto: "failed"),
    6: .standard(proto: "total_num_cached"),
    7: .standard(proto: "first_start_time_millis"),
    8: .standard(proto: "last_stop_time_millis"),
    9: .standard(proto: "total_run_duration_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.totalRunCount)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.passed)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.failed)
      case 5: try decoder.decodeSingularEnumField(value: &self.overallStatus)
      case 6: try decoder.decodeSingularInt32Field(value: &self.totalNumCached)
      case 7: try decoder.decodeSingularInt64Field(value: &self.firstStartTimeMillis)
      case 8: try decoder.decodeSingularInt64Field(value: &self.lastStopTimeMillis)
      case 9: try decoder.decodeSingularInt64Field(value: &self.totalRunDurationMillis)
      case 10: try decoder.decodeSingularInt32Field(value: &self.runCount)
      case 11: try decoder.decodeSingularInt32Field(value: &self.shardCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalRunCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRunCount, fieldNumber: 1)
    }
    if !self.passed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.passed, fieldNumber: 3)
    }
    if !self.failed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failed, fieldNumber: 4)
    }
    if self.overallStatus != .noStatus {
      try visitor.visitSingularEnumField(value: self.overallStatus, fieldNumber: 5)
    }
    if self.totalNumCached != 0 {
      try visitor.visitSingularInt32Field(value: self.totalNumCached, fieldNumber: 6)
    }
    if self.firstStartTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.firstStartTimeMillis, fieldNumber: 7)
    }
    if self.lastStopTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.lastStopTimeMillis, fieldNumber: 8)
    }
    if self.totalRunDurationMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.totalRunDurationMillis, fieldNumber: 9)
    }
    if self.runCount != 0 {
      try visitor.visitSingularInt32Field(value: self.runCount, fieldNumber: 10)
    }
    if self.shardCount != 0 {
      try visitor.visitSingularInt32Field(value: self.shardCount, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestSummary, rhs: BuildEventStream_TestSummary) -> Bool {
    if lhs.overallStatus != rhs.overallStatus {return false}
    if lhs.totalRunCount != rhs.totalRunCount {return false}
    if lhs.runCount != rhs.runCount {return false}
    if lhs.shardCount != rhs.shardCount {return false}
    if lhs.passed != rhs.passed {return false}
    if lhs.failed != rhs.failed {return false}
    if lhs.totalNumCached != rhs.totalNumCached {return false}
    if lhs.firstStartTimeMillis != rhs.firstStartTimeMillis {return false}
    if lhs.lastStopTimeMillis != rhs.lastStopTimeMillis {return false}
    if lhs.totalRunDurationMillis != rhs.totalRunDurationMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_build_success"),
    2: .standard(proto: "overall_test_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.overallBuildSuccess)
      case 2: try decoder.decodeSingularEnumField(value: &self.overallTestStatus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overallBuildSuccess != false {
      try visitor.visitSingularBoolField(value: self.overallBuildSuccess, fieldNumber: 1)
    }
    if self.overallTestStatus != .noStatus {
      try visitor.visitSingularEnumField(value: self.overallTestStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetSummary, rhs: BuildEventStream_TargetSummary) -> Bool {
    if lhs.overallBuildSuccess != rhs.overallBuildSuccess {return false}
    if lhs.overallTestStatus != rhs.overallTestStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildFinished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_success"),
    3: .standard(proto: "exit_code"),
    2: .standard(proto: "finish_time_millis"),
    4: .standard(proto: "anomaly_report"),
  ]

  fileprivate class _StorageClass {
    var _overallSuccess: Bool = false
    var _exitCode: BuildEventStream_BuildFinished.ExitCode? = nil
    var _finishTimeMillis: Int64 = 0
    var _anomalyReport: BuildEventStream_BuildFinished.AnomalyReport? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _overallSuccess = source._overallSuccess
      _exitCode = source._exitCode
      _finishTimeMillis = source._finishTimeMillis
      _anomalyReport = source._anomalyReport
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._overallSuccess)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._finishTimeMillis)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._exitCode)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._anomalyReport)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._overallSuccess != false {
        try visitor.visitSingularBoolField(value: _storage._overallSuccess, fieldNumber: 1)
      }
      if _storage._finishTimeMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._finishTimeMillis, fieldNumber: 2)
      }
      if let v = _storage._exitCode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._anomalyReport {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished, rhs: BuildEventStream_BuildFinished) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._overallSuccess != rhs_storage._overallSuccess {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._finishTimeMillis != rhs_storage._finishTimeMillis {return false}
        if _storage._anomalyReport != rhs_storage._anomalyReport {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.ExitCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".ExitCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt32Field(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.ExitCode, rhs: BuildEventStream_BuildFinished.ExitCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.AnomalyReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".AnomalyReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "was_suspended"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.wasSuspended)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wasSuspended != false {
      try visitor.visitSingularBoolField(value: self.wasSuspended, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.AnomalyReport, rhs: BuildEventStream_BuildFinished.AnomalyReport) -> Bool {
    if lhs.wasSuspended != rhs.wasSuspended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_summary"),
    2: .standard(proto: "memory_metrics"),
    3: .standard(proto: "target_metrics"),
    4: .standard(proto: "package_metrics"),
    5: .standard(proto: "timing_metrics"),
    6: .standard(proto: "cumulative_metrics"),
    7: .standard(proto: "artifact_metrics"),
    8: .standard(proto: "build_graph_metrics"),
  ]

  fileprivate class _StorageClass {
    var _actionSummary: BuildEventStream_BuildMetrics.ActionSummary? = nil
    var _memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics? = nil
    var _targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics? = nil
    var _packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics? = nil
    var _timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics? = nil
    var _cumulativeMetrics: BuildEventStream_BuildMetrics.CumulativeMetrics? = nil
    var _artifactMetrics: BuildEventStream_BuildMetrics.ArtifactMetrics? = nil
    var _buildGraphMetrics: BuildEventStream_BuildMetrics.BuildGraphMetrics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actionSummary = source._actionSummary
      _memoryMetrics = source._memoryMetrics
      _targetMetrics = source._targetMetrics
      _packageMetrics = source._packageMetrics
      _timingMetrics = source._timingMetrics
      _cumulativeMetrics = source._cumulativeMetrics
      _artifactMetrics = source._artifactMetrics
      _buildGraphMetrics = source._buildGraphMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._actionSummary)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._memoryMetrics)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._targetMetrics)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._packageMetrics)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._timingMetrics)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._cumulativeMetrics)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._artifactMetrics)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._buildGraphMetrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._actionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._memoryMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._targetMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._packageMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._timingMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._cumulativeMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._artifactMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._buildGraphMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics, rhs: BuildEventStream_BuildMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actionSummary != rhs_storage._actionSummary {return false}
        if _storage._memoryMetrics != rhs_storage._memoryMetrics {return false}
        if _storage._targetMetrics != rhs_storage._targetMetrics {return false}
        if _storage._packageMetrics != rhs_storage._packageMetrics {return false}
        if _storage._timingMetrics != rhs_storage._timingMetrics {return false}
        if _storage._cumulativeMetrics != rhs_storage._cumulativeMetrics {return false}
        if _storage._artifactMetrics != rhs_storage._artifactMetrics {return false}
        if _storage._buildGraphMetrics != rhs_storage._buildGraphMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ActionSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actions_created"),
    3: .standard(proto: "actions_created_not_including_aspects"),
    2: .standard(proto: "actions_executed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.actionsCreated)
      case 2: try decoder.decodeSingularInt64Field(value: &self.actionsExecuted)
      case 3: try decoder.decodeSingularInt64Field(value: &self.actionsCreatedNotIncludingAspects)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsCreated != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreated, fieldNumber: 1)
    }
    if self.actionsExecuted != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsExecuted, fieldNumber: 2)
    }
    if self.actionsCreatedNotIncludingAspects != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreatedNotIncludingAspects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary, rhs: BuildEventStream_BuildMetrics.ActionSummary) -> Bool {
    if lhs.actionsCreated != rhs.actionsCreated {return false}
    if lhs.actionsCreatedNotIncludingAspects != rhs.actionsCreatedNotIncludingAspects {return false}
    if lhs.actionsExecuted != rhs.actionsExecuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.MemoryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".MemoryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "used_heap_size_post_build"),
    2: .standard(proto: "peak_post_gc_heap_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.usedHeapSizePostBuild)
      case 2: try decoder.decodeSingularInt64Field(value: &self.peakPostGcHeapSize)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usedHeapSizePostBuild != 0 {
      try visitor.visitSingularInt64Field(value: self.usedHeapSizePostBuild, fieldNumber: 1)
    }
    if self.peakPostGcHeapSize != 0 {
      try visitor.visitSingularInt64Field(value: self.peakPostGcHeapSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.MemoryMetrics, rhs: BuildEventStream_BuildMetrics.MemoryMetrics) -> Bool {
    if lhs.usedHeapSizePostBuild != rhs.usedHeapSizePostBuild {return false}
    if lhs.peakPostGcHeapSize != rhs.peakPostGcHeapSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TargetMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TargetMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "targets_loaded"),
    2: .standard(proto: "targets_configured"),
    3: .standard(proto: "targets_configured_not_including_aspects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.targetsLoaded)
      case 2: try decoder.decodeSingularInt64Field(value: &self.targetsConfigured)
      case 3: try decoder.decodeSingularInt64Field(value: &self.targetsConfiguredNotIncludingAspects)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetsLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsLoaded, fieldNumber: 1)
    }
    if self.targetsConfigured != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsConfigured, fieldNumber: 2)
    }
    if self.targetsConfiguredNotIncludingAspects != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsConfiguredNotIncludingAspects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TargetMetrics, rhs: BuildEventStream_BuildMetrics.TargetMetrics) -> Bool {
    if lhs.targetsLoaded != rhs.targetsLoaded {return false}
    if lhs.targetsConfigured != rhs.targetsConfigured {return false}
    if lhs.targetsConfiguredNotIncludingAspects != rhs.targetsConfiguredNotIncludingAspects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.PackageMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".PackageMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packages_loaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.packagesLoaded)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packagesLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.packagesLoaded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.PackageMetrics, rhs: BuildEventStream_BuildMetrics.PackageMetrics) -> Bool {
    if lhs.packagesLoaded != rhs.packagesLoaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TimingMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TimingMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_time_in_ms"),
    2: .standard(proto: "wall_time_in_ms"),
    3: .standard(proto: "analysis_phase_time_in_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.cpuTimeInMs)
      case 2: try decoder.decodeSingularInt64Field(value: &self.wallTimeInMs)
      case 3: try decoder.decodeSingularInt64Field(value: &self.analysisPhaseTimeInMs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuTimeInMs, fieldNumber: 1)
    }
    if self.wallTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.wallTimeInMs, fieldNumber: 2)
    }
    if self.analysisPhaseTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.analysisPhaseTimeInMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TimingMetrics, rhs: BuildEventStream_BuildMetrics.TimingMetrics) -> Bool {
    if lhs.cpuTimeInMs != rhs.cpuTimeInMs {return false}
    if lhs.wallTimeInMs != rhs.wallTimeInMs {return false}
    if lhs.analysisPhaseTimeInMs != rhs.analysisPhaseTimeInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.CumulativeMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".CumulativeMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "num_analyses"),
    12: .standard(proto: "num_builds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 11: try decoder.decodeSingularInt32Field(value: &self.numAnalyses)
      case 12: try decoder.decodeSingularInt32Field(value: &self.numBuilds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numAnalyses != 0 {
      try visitor.visitSingularInt32Field(value: self.numAnalyses, fieldNumber: 11)
    }
    if self.numBuilds != 0 {
      try visitor.visitSingularInt32Field(value: self.numBuilds, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.CumulativeMetrics, rhs: BuildEventStream_BuildMetrics.CumulativeMetrics) -> Bool {
    if lhs.numAnalyses != rhs.numAnalyses {return false}
    if lhs.numBuilds != rhs.numBuilds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ArtifactMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ArtifactMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "source_artifacts_read"),
    3: .standard(proto: "output_artifacts_seen"),
    4: .standard(proto: "output_artifacts_from_action_cache"),
    5: .standard(proto: "top_level_artifacts"),
  ]

  fileprivate class _StorageClass {
    var _sourceArtifactsRead: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
    var _outputArtifactsSeen: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
    var _outputArtifactsFromActionCache: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
    var _topLevelArtifacts: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sourceArtifactsRead = source._sourceArtifactsRead
      _outputArtifactsSeen = source._outputArtifactsSeen
      _outputArtifactsFromActionCache = source._outputArtifactsFromActionCache
      _topLevelArtifacts = source._topLevelArtifacts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sourceArtifactsRead)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._outputArtifactsSeen)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._outputArtifactsFromActionCache)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._topLevelArtifacts)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sourceArtifactsRead {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._outputArtifactsSeen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._outputArtifactsFromActionCache {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._topLevelArtifacts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ArtifactMetrics, rhs: BuildEventStream_BuildMetrics.ArtifactMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sourceArtifactsRead != rhs_storage._sourceArtifactsRead {return false}
        if _storage._outputArtifactsSeen != rhs_storage._outputArtifactsSeen {return false}
        if _storage._outputArtifactsFromActionCache != rhs_storage._outputArtifactsFromActionCache {return false}
        if _storage._topLevelArtifacts != rhs_storage._topLevelArtifacts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.ArtifactMetrics.protoMessageName + ".FilesMetric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "size_in_bytes"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.sizeInBytes)
      case 2: try decoder.decodeSingularInt32Field(value: &self.count)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sizeInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeInBytes, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric, rhs: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric) -> Bool {
    if lhs.sizeInBytes != rhs.sizeInBytes {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.BuildGraphMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".BuildGraphMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_lookup_value_count"),
    5: .standard(proto: "action_lookup_value_count_not_including_aspects"),
    2: .standard(proto: "action_count"),
    6: .standard(proto: "action_count_not_including_aspects"),
    3: .standard(proto: "output_artifact_count"),
    4: .standard(proto: "post_invocation_skyframe_node_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.actionLookupValueCount)
      case 2: try decoder.decodeSingularInt32Field(value: &self.actionCount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.outputArtifactCount)
      case 4: try decoder.decodeSingularInt32Field(value: &self.postInvocationSkyframeNodeCount)
      case 5: try decoder.decodeSingularInt32Field(value: &self.actionLookupValueCountNotIncludingAspects)
      case 6: try decoder.decodeSingularInt32Field(value: &self.actionCountNotIncludingAspects)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionLookupValueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.actionLookupValueCount, fieldNumber: 1)
    }
    if self.actionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.actionCount, fieldNumber: 2)
    }
    if self.outputArtifactCount != 0 {
      try visitor.visitSingularInt32Field(value: self.outputArtifactCount, fieldNumber: 3)
    }
    if self.postInvocationSkyframeNodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.postInvocationSkyframeNodeCount, fieldNumber: 4)
    }
    if self.actionLookupValueCountNotIncludingAspects != 0 {
      try visitor.visitSingularInt32Field(value: self.actionLookupValueCountNotIncludingAspects, fieldNumber: 5)
    }
    if self.actionCountNotIncludingAspects != 0 {
      try visitor.visitSingularInt32Field(value: self.actionCountNotIncludingAspects, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.BuildGraphMetrics, rhs: BuildEventStream_BuildMetrics.BuildGraphMetrics) -> Bool {
    if lhs.actionLookupValueCount != rhs.actionLookupValueCount {return false}
    if lhs.actionLookupValueCountNotIncludingAspects != rhs.actionLookupValueCountNotIncludingAspects {return false}
    if lhs.actionCount != rhs.actionCount {return false}
    if lhs.actionCountNotIncludingAspects != rhs.actionCountNotIncludingAspects {return false}
    if lhs.outputArtifactCount != rhs.outputArtifactCount {return false}
    if lhs.postInvocationSkyframeNodeCount != rhs.postInvocationSkyframeNodeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildToolLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildToolLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.log)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildToolLogs, rhs: BuildEventStream_BuildToolLogs) -> Bool {
    if lhs.log != rhs.log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlinksIdentified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlinksIdentified"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "convenience_symlinks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.convenienceSymlinks)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.convenienceSymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.convenienceSymlinks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlinksIdentified, rhs: BuildEventStream_ConvenienceSymlinksIdentified) -> Bool {
    if lhs.convenienceSymlinks != rhs.convenienceSymlinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "action"),
    3: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularEnumField(value: &self.action)
      case 3: try decoder.decodeSingularStringField(value: &self.target)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlink, rhs: BuildEventStream_ConvenienceSymlink) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.action != rhs.action {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "DELETE"),
  ]
}

extension BuildEventStream_BuildEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "children"),
    20: .standard(proto: "last_message"),
    3: .same(proto: "progress"),
    4: .same(proto: "aborted"),
    5: .same(proto: "started"),
    12: .standard(proto: "unstructured_command_line"),
    22: .standard(proto: "structured_command_line"),
    13: .standard(proto: "options_parsed"),
    16: .standard(proto: "workspace_status"),
    21: .same(proto: "fetch"),
    17: .same(proto: "configuration"),
    6: .same(proto: "expanded"),
    18: .same(proto: "configured"),
    7: .same(proto: "action"),
    15: .standard(proto: "named_set_of_files"),
    8: .same(proto: "completed"),
    10: .standard(proto: "test_result"),
    9: .standard(proto: "test_summary"),
    28: .standard(proto: "target_summary"),
    14: .same(proto: "finished"),
    23: .standard(proto: "build_tool_logs"),
    24: .standard(proto: "build_metrics"),
    25: .standard(proto: "workspace_info"),
    26: .standard(proto: "build_metadata"),
    27: .standard(proto: "convenience_symlinks_identified"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId? = nil
    var _children: [BuildEventStream_BuildEventId] = []
    var _lastMessage: Bool = false
    var _payload: BuildEventStream_BuildEvent.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _children = source._children
      _lastMessage = source._lastMessage
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._children)
        case 3:
          var v: BuildEventStream_Progress?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .progress(v)}
        case 4:
          var v: BuildEventStream_Aborted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .aborted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .aborted(v)}
        case 5:
          var v: BuildEventStream_BuildStarted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .started(v)}
        case 6:
          var v: BuildEventStream_PatternExpanded?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .expanded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .expanded(v)}
        case 7:
          var v: BuildEventStream_ActionExecuted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .action(v)}
        case 8:
          var v: BuildEventStream_TargetComplete?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .completed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .completed(v)}
        case 9:
          var v: BuildEventStream_TestSummary?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .testSummary(v)}
        case 10:
          var v: BuildEventStream_TestResult?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .testResult(v)}
        case 12:
          var v: BuildEventStream_UnstructuredCommandLine?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .unstructuredCommandLine(v)}
        case 13:
          var v: BuildEventStream_OptionsParsed?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .optionsParsed(v)}
        case 14:
          var v: BuildEventStream_BuildFinished?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .finished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .finished(v)}
        case 15:
          var v: BuildEventStream_NamedSetOfFiles?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .namedSetOfFiles(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .namedSetOfFiles(v)}
        case 16:
          var v: BuildEventStream_WorkspaceStatus?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .workspaceStatus(v)}
        case 17:
          var v: BuildEventStream_Configuration?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .configuration(v)}
        case 18:
          var v: BuildEventStream_TargetConfigured?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .configured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .configured(v)}
        case 20: try decoder.decodeSingularBoolField(value: &_storage._lastMessage)
        case 21:
          var v: BuildEventStream_Fetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .fetch(v)}
        case 22:
          var v: CommandLine_CommandLine?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .structuredCommandLine(v)}
        case 23:
          var v: BuildEventStream_BuildToolLogs?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildToolLogs(v)}
        case 24:
          var v: BuildEventStream_BuildMetrics?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildMetrics(v)}
        case 25:
          var v: BuildEventStream_WorkspaceConfig?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .workspaceInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .workspaceInfo(v)}
        case 26:
          var v: BuildEventStream_BuildMetadata?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildMetadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildMetadata(v)}
        case 27:
          var v: BuildEventStream_ConvenienceSymlinksIdentified?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .convenienceSymlinksIdentified(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .convenienceSymlinksIdentified(v)}
        case 28:
          var v: BuildEventStream_TargetSummary?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .targetSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .targetSummary(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 2)
      }
      switch _storage._payload {
      case .progress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .aborted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .started(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .expanded(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .action(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .completed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .testSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .testResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .unstructuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .optionsParsed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .finished(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .namedSetOfFiles(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .workspaceStatus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .configuration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .configured(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case nil: break
      default: break
      }
      if _storage._lastMessage != false {
        try visitor.visitSingularBoolField(value: _storage._lastMessage, fieldNumber: 20)
      }
      switch _storage._payload {
      case .fetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .structuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .buildToolLogs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .buildMetrics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .workspaceInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .buildMetadata(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .convenienceSymlinksIdentified(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .targetSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEvent, rhs: BuildEventStream_BuildEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
