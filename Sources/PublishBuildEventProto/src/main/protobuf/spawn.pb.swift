// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/spawn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Tools_Protos_Digest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Digest of a file's contents using the current FileSystem digest function.
  public var hash: String = String()

  /// The size in bytes of the original content.
  public var sizeBytes: Int64 = 0

  /// The digest function that was used to generate the hash.
  /// This is not an enum for compatibility reasons, and also because the
  /// purpose of these logs is to enable analysis by comparison of multiple
  /// builds. So, from the programmatic perspective, this is an opaque field.
  public var hashFunctionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tools_Protos_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the file relative to the execution root.
  public var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// Digest of the file's contents.
  public var digest: Tools_Protos_Digest {
    get {return _storage._digest ?? Tools_Protos_Digest()}
    set {_uniqueStorage()._digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return _storage._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {_uniqueStorage()._digest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Contents of command environment.
public struct Tools_Protos_EnvironmentVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Command execution platform. This message needs to be kept in sync
/// with [Platform][google.devtools.remoteexecution.v1test.Platform].
public struct Tools_Protos_Platform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var properties: [Tools_Protos_Platform.Property] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Property {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Details of an executed spawn.
/// These will only be generated on demand, using the
/// --execution_log_file=<path> flag.
/// Each message contains an executed command, its full inputs and outputs.
/// The purpose of these is to enable comparisons of multiple builds to diagnose
/// output differences or more subtle problems such as remote caching misses.
/// Only the executed Spawns will be output -- local cache hits are ignored.
public struct Tools_Protos_SpawnExec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The command that was run.
  public var commandArgs: [String] {
    get {return _storage._commandArgs}
    set {_uniqueStorage()._commandArgs = newValue}
  }

  /// The command environment.
  public var environmentVariables: [Tools_Protos_EnvironmentVariable] {
    get {return _storage._environmentVariables}
    set {_uniqueStorage()._environmentVariables = newValue}
  }

  /// The command execution platform.
  public var platform: Tools_Protos_Platform {
    get {return _storage._platform ?? Tools_Protos_Platform()}
    set {_uniqueStorage()._platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return _storage._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {_uniqueStorage()._platform = nil}

  /// The inputs at the time of the execution.
  public var inputs: [Tools_Protos_File] {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  /// All the listed outputs paths. The paths are relative to the execution root.
  /// Actual outputs are a subset of the listed outputs. These paths are sorted.
  public var listedOutputs: [String] {
    get {return _storage._listedOutputs}
    set {_uniqueStorage()._listedOutputs = newValue}
  }

  /// Was the Spawn allowed to be executed remotely.
  public var remotable: Bool {
    get {return _storage._remotable}
    set {_uniqueStorage()._remotable = newValue}
  }

  /// Was the Spawn result allowed to be cached.
  public var cacheable: Bool {
    get {return _storage._cacheable}
    set {_uniqueStorage()._cacheable = newValue}
  }

  /// The Spawn timeout.
  public var timeoutMillis: Int64 {
    get {return _storage._timeoutMillis}
    set {_uniqueStorage()._timeoutMillis = newValue}
  }

  /// A user-friendly text message representing the spawn progress.
  public var progressMessage: String {
    get {return _storage._progressMessage}
    set {_uniqueStorage()._progressMessage = newValue}
  }

  /// An opaque string that identifies the type of the Spawn's action.
  public var mnemonic: String {
    get {return _storage._mnemonic}
    set {_uniqueStorage()._mnemonic = newValue}
  }

  /// The outputs generated by the execution.
  public var actualOutputs: [Tools_Protos_File] {
    get {return _storage._actualOutputs}
    set {_uniqueStorage()._actualOutputs = newValue}
  }

  /// If the Spawn was actually executed, rather than a cache hit,
  /// this will be the name of the runner executing the spawn, e.g. remote or
  /// linux-sandbox. If it was a remote cache hit, the runner will be
  /// "remote cache hit". If it was a local cache hit, the action will not be
  /// included in the log in the first place.
  ///
  /// Note, this is not the same as the "strategy" string -- even
  /// though the action strategy may be remote. A particular action may still
  /// fall back to local execution due to a variety of reasons. This field
  /// indicates what really happened for the particular Spawn+execution.
  public var runner: String {
    get {return _storage._runner}
    set {_uniqueStorage()._runner = newValue}
  }

  /// Whether the Spawn was a remote cache hit, in which case it was not executed
  /// and the runner field will be empty.
  public var remoteCacheHit: Bool {
    get {return _storage._remoteCacheHit}
    set {_uniqueStorage()._remoteCacheHit = newValue}
  }

  /// A text status returned by the execution, in case there were any errors.
  /// Empty in case of successful execution.
  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// This field contains the contents of SpawnResult.exitCode.
  /// Its semantics varies greatly depending on the status field.
  /// Dependable: if status is empty, exit_code is guaranteed to be zero.
  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tools.protos"

extension Tools_Protos_Digest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Digest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "size_bytes"),
    3: .standard(proto: "hash_function_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.sizeBytes)
      case 3: try decoder.decodeSingularStringField(value: &self.hashFunctionName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 2)
    }
    if !self.hashFunctionName.isEmpty {
      try visitor.visitSingularStringField(value: self.hashFunctionName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_Digest, rhs: Tools_Protos_Digest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.hashFunctionName != rhs.hashFunctionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "digest"),
  ]

  fileprivate class _StorageClass {
    var _path: String = String()
    var _digest: Tools_Protos_Digest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _path = source._path
      _digest = source._digest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._path)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._digest)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 1)
      }
      if let v = _storage._digest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_File, rhs: Tools_Protos_File) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._path != rhs_storage._path {return false}
        if _storage._digest != rhs_storage._digest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvironmentVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_EnvironmentVariable, rhs: Tools_Protos_EnvironmentVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_Platform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Platform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.properties)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_Platform, rhs: Tools_Protos_Platform) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_Platform.Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tools_Protos_Platform.protoMessageName + ".Property"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_Platform.Property, rhs: Tools_Protos_Platform.Property) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_SpawnExec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpawnExec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_args"),
    2: .standard(proto: "environment_variables"),
    3: .same(proto: "platform"),
    4: .same(proto: "inputs"),
    5: .standard(proto: "listed_outputs"),
    6: .same(proto: "remotable"),
    7: .same(proto: "cacheable"),
    8: .standard(proto: "timeout_millis"),
    9: .standard(proto: "progress_message"),
    10: .same(proto: "mnemonic"),
    11: .standard(proto: "actual_outputs"),
    12: .same(proto: "runner"),
    13: .standard(proto: "remote_cache_hit"),
    14: .same(proto: "status"),
    15: .standard(proto: "exit_code"),
  ]

  fileprivate class _StorageClass {
    var _commandArgs: [String] = []
    var _environmentVariables: [Tools_Protos_EnvironmentVariable] = []
    var _platform: Tools_Protos_Platform? = nil
    var _inputs: [Tools_Protos_File] = []
    var _listedOutputs: [String] = []
    var _remotable: Bool = false
    var _cacheable: Bool = false
    var _timeoutMillis: Int64 = 0
    var _progressMessage: String = String()
    var _mnemonic: String = String()
    var _actualOutputs: [Tools_Protos_File] = []
    var _runner: String = String()
    var _remoteCacheHit: Bool = false
    var _status: String = String()
    var _exitCode: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commandArgs = source._commandArgs
      _environmentVariables = source._environmentVariables
      _platform = source._platform
      _inputs = source._inputs
      _listedOutputs = source._listedOutputs
      _remotable = source._remotable
      _cacheable = source._cacheable
      _timeoutMillis = source._timeoutMillis
      _progressMessage = source._progressMessage
      _mnemonic = source._mnemonic
      _actualOutputs = source._actualOutputs
      _runner = source._runner
      _remoteCacheHit = source._remoteCacheHit
      _status = source._status
      _exitCode = source._exitCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._commandArgs)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._environmentVariables)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._platform)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._inputs)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._listedOutputs)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._remotable)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._cacheable)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._timeoutMillis)
        case 9: try decoder.decodeSingularStringField(value: &_storage._progressMessage)
        case 10: try decoder.decodeSingularStringField(value: &_storage._mnemonic)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._actualOutputs)
        case 12: try decoder.decodeSingularStringField(value: &_storage._runner)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._remoteCacheHit)
        case 14: try decoder.decodeSingularStringField(value: &_storage._status)
        case 15: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._commandArgs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandArgs, fieldNumber: 1)
      }
      if !_storage._environmentVariables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._environmentVariables, fieldNumber: 2)
      }
      if let v = _storage._platform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputs, fieldNumber: 4)
      }
      if !_storage._listedOutputs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._listedOutputs, fieldNumber: 5)
      }
      if _storage._remotable != false {
        try visitor.visitSingularBoolField(value: _storage._remotable, fieldNumber: 6)
      }
      if _storage._cacheable != false {
        try visitor.visitSingularBoolField(value: _storage._cacheable, fieldNumber: 7)
      }
      if _storage._timeoutMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeoutMillis, fieldNumber: 8)
      }
      if !_storage._progressMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._progressMessage, fieldNumber: 9)
      }
      if !_storage._mnemonic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mnemonic, fieldNumber: 10)
      }
      if !_storage._actualOutputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actualOutputs, fieldNumber: 11)
      }
      if !_storage._runner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runner, fieldNumber: 12)
      }
      if _storage._remoteCacheHit != false {
        try visitor.visitSingularBoolField(value: _storage._remoteCacheHit, fieldNumber: 13)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 14)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_SpawnExec, rhs: Tools_Protos_SpawnExec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commandArgs != rhs_storage._commandArgs {return false}
        if _storage._environmentVariables != rhs_storage._environmentVariables {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        if _storage._listedOutputs != rhs_storage._listedOutputs {return false}
        if _storage._remotable != rhs_storage._remotable {return false}
        if _storage._cacheable != rhs_storage._cacheable {return false}
        if _storage._timeoutMillis != rhs_storage._timeoutMillis {return false}
        if _storage._progressMessage != rhs_storage._progressMessage {return false}
        if _storage._mnemonic != rhs_storage._mnemonic {return false}
        if _storage._actualOutputs != rhs_storage._actualOutputs {return false}
        if _storage._runner != rhs_storage._runner {return false}
        if _storage._remoteCacheHit != rhs_storage._remoteCacheHit {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
